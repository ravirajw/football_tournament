<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Football Tournament Manager</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        min-height: 100vh;
        padding: 16px;
      }

      .container {
        max-width: 1200px;
        margin: 0 auto;
        background: white;
        border-radius: 16px;
        padding: 16px;
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
      }

      h1 {
        text-align: center;
        color: #333;
        margin-bottom: 30px;
        font-size: 2.5em;
      }

      .section {
        margin-bottom: 30px;
        padding: 20px;
        background: #f8f9fa;
        border-radius: 10px;
      }

      .section h2 {
        color: #667eea;
        margin-bottom: 15px;
        border-bottom: 3px solid #667eea;
        padding-bottom: 10px;
      }

      .team-setup {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
        gap: 20px;
      }

      .team-card {
        padding: 15px;
        border-radius: 10px;
        color: white;
      }

      .team-red {
        background: linear-gradient(135deg, #d32f2f, #c62828);
      }

      .team-black {
        background: linear-gradient(135deg, #424242, #212121);
      }

      .team-white {
        background: linear-gradient(135deg, #bdbdbd, #9e9e9e);
        color: #333;
      }

      .team-card h3 {
        margin-bottom: 15px;
        font-size: 1.5em;
      }

      .player-input {
        display: flex;
        gap: 10px;
        margin-bottom: 10px;
      }

      input[type="text"] {
        flex: 1;
        padding: 10px;
        border: none;
        border-radius: 5px;
        font-size: 14px;
      }

      button {
        padding: 10px 20px;
        border: none;
        border-radius: 5px;
        cursor: pointer;
        font-size: 14px;
        font-weight: bold;
        transition: all 0.3s;
      }

      .btn-primary {
        background: #667eea;
        color: white;
      }

      .btn-primary:hover {
        background: #5568d3;
        transform: translateY(-2px);
      }

      .btn-success {
        background: #28a745;
        color: white;
      }

      .btn-success:hover {
        background: #218839;
        transform: translateY(-2px);
      }

      .btn-danger {
        background: #dc3545;
        color: white;
      }

      .btn-danger:hover {
        background: #c82333;
        transform: translateY(-2px);
      }

      .btn-warning {
        background: #ffc107;
        color: #333;
      }

      /* Match Control Button Styles - Only for match action buttons */
      .match-action-btn {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        padding: 20px 10px;
        border: none;
        border-radius: 8px;
        cursor: pointer;
        font-size: 14px;
        font-weight: 600;
        transition: all 0.3s ease;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        line-height: 1.3;
        text-align: center;
        color: white;
      }

      .match-action-btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.15);
      }

      .match-action-btn:active {
        transform: translateY(0);
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      }

      /* Add Goal - Green */
      .match-btn-goal {
        background-color: #28a745;
      }

      .match-btn-goal:hover {
        background-color: #218838;
      }

      /* Add Own Goal - Purple */
      .match-btn-own-goal {
        background-color: #9c27b0;
      }

      .match-btn-own-goal:hover {
        background-color: #7b1fa2;
      }

      /* Match Control Buttons - Blue */
      .match-btn-control {
        background-color: #1976d2;
      }

      .match-btn-control:hover {
        background-color: #1565c0;
      }

      /* Full width match buttons */
      .match-btn-full {
        flex-direction: row;
        gap: 10px;
        padding: 15px 10px;
      }

      .match-action-btn .icon-large {
        font-size: 24px;
        margin-bottom: 6px;
      }

      .player-list {
        margin-top: 16px;
      }

      .player-item {
        background: rgba(255, 255, 255, 0.2);
        padding: 8px;
        margin: 4px 0;
        border-radius: 4px;
        display: flex;
        justify-content: space-between;
        align-items: center;
      }

      .team-white .player-item {
        background: rgba(0, 0, 0, 0.1);
      }

      .matches-grid {
        display: grid;
        gap: 15px;
      }

      .match-card {
        background: white;
        padding: 20px;
        border-radius: 10px;
        border: 2px solid #e0e0e0;
      }

      .match-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 15px;
        flex-wrap: wrap;
        gap: 10px;
      }

      .match-header-title {
        font-weight: bold;
      }

      .match-header-status {
        display: flex;
        align-items: center;
        gap: 8px;
      }

      /* New scoreboard layout */
      .match-scoreboard {
        margin: 15px 0;
      }

      .team-score-row {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 12px 0;
        border-bottom: 1px solid #f0f0f0;
      }

      .team-score-row:last-child {
        border-bottom: none;
      }

      .team-info {
        display: flex;
        flex-direction: column;
        gap: 5px;
        flex: 1;
      }

      .team-name {
        font-size: 1.3em;
        font-weight: bold;
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .team-keeper {
        font-size: 0.9em;
        color: #666;
        padding-left: 8px;
        display: flex;
        align-items: center;
        gap: 5px;
      }

      .team-score {
        font-size: 2em;
        font-weight: bold;
        color: #667eea;
        min-width: 50px;
        text-align: right;
      }

      /* Legacy styles for backward compatibility */
      .match-teams {
        display: flex;
        justify-content: space-around;
        align-items: center;
        margin: 20px 0;
        font-size: 1.5em;
        font-weight: bold;
      }

      .score {
        font-size: 2em;
        color: #667eea;
      }

      .match-controls {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
        gap: 10px;
        margin-top: 15px;
      }

      @media (max-width: 480px) {
        .match-controls {
          grid-template-columns: 1fr 1fr;
        }
      }

      .goal-section {
        margin-top: 15px;
        padding: 15px;
        background: #f0f0f0;
        border-radius: 8px;
      }

      .points-table {
        width: 100%;
        border-collapse: collapse;
        margin-top: 20px;
      }

      .points-table th,
      .points-table td {
        padding: 12px;
        text-align: left;
        border-bottom: 1px solid #ddd;
      }

      .points-table th {
        background: #667eea;
        color: white;
        font-weight: bold;
      }

      .points-table tr:hover {
        background: #f5f5f5;
      }

      .timer {
        font-size: 2em;
        font-weight: bold;
        color: #667eea;
        text-align: center;
        margin: 10px 0;
      }

      .goal-log {
        margin-top: 10px;
        max-height: 150px;
        overflow-y: auto;
      }

      .goal-item {
        padding: 5px;
        margin: 3px 0;
        background: #e8f5e9;
        border-radius: 5px;
        font-size: 0.9em;
      }

      .save-item {
        background: #e3f2fd;
      }

      .own-goal {
        background: #ffebee;
      }

      .hidden {
        display: none;
      }

      .final-match {
        border: 3px solid gold;
        background: linear-gradient(135deg, #fff9c4, #fff59d);
      }

      .winner-announcement {
        text-align: center;
        padding: 30px;
        background: linear-gradient(135deg, #ffd700, #ffed4e);
        border-radius: 15px;
        margin: 20px 0;
      }

      .winner-announcement h2 {
        color: #333;
        font-size: 2.5em;
        margin-bottom: 10px;
      }

      .remove-btn {
        background: rgba(220, 53, 69, 0.8);
        color: white;
        padding: 4px 8px;
        font-size: 12px;
      }

      .tiebreaker-modal {
        background: #fff3cd;
        border: 2px solid #ffc107;
        padding: 20px;
        border-radius: 10px;
        margin: 20px 0;
      }

      .tiebreaker-modal h3 {
        color: #856404;
        margin-bottom: 15px;
      }

      .team-option {
        padding: 15px;
        margin: 10px 0;
        border-radius: 8px;
        cursor: pointer;
        border: 2px solid #dee2e6;
        transition: all 0.3s;
        font-weight: bold;
      }

      .team-option:hover {
        border-color: #667eea;
        background: #f8f9fa;
        transform: translateX(5px);
      }

      .whatsapp-message-box {
        background: #e7f3e7;
        border: 2px solid #25d366;
        border-radius: 10px;
        padding: 20px;
        margin: 20px 0;
      }

      .whatsapp-message-box h3 {
        color: #075e54;
        margin-bottom: 15px;
        display: flex;
        align-items: center;
        gap: 10px;
      }

      .message-content {
        background: white;
        padding: 15px;
        border-radius: 8px;
        font-family: monospace;
        white-space: pre-wrap;
        font-size: 0.9em;
        max-height: 400px;
        overflow-y: auto;
        border: 1px solid #ddd;
        text-align: left;
      }

      .copy-btn {
        background: #25d366;
        color: white;
        padding: 12px 24px;
        margin-top: 10px;
        border-radius: 8px;
        font-size: 16px;
        cursor: pointer;
        border: none;
        transition: all 0.3s;
      }

      .copy-btn:hover {
        background: #128c7e;
        transform: translateY(-2px);
      }

      .modal {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.5);
        z-index: 1000;
        justify-content: center;
        align-items: center;
      }

      .modal-content {
        background: white;
        padding: 30px;
        border-radius: 15px;
        max-width: 500px;
        width: 90%;
      }

      .keeper-selection {
        margin: 15px 0;
      }

      .keeper-selection h3 {
        margin-bottom: 10px;
        font-size: 1.2em;
      }

      .keeper-info {
        display: flex;
        justify-content: space-around;
        margin: 10px 0;
        font-size: 0.9em;
        color: #666;
      }
    </style>
  </head>

  <body>
    <div class="container">
      <div id="header-container"></div>

      <style>
        @keyframes spin {
          0% {
            transform: rotate(0deg);
          }

          100% {
            transform: rotate(360deg);
          }
        }

        .page {
          display: none;
        }

        .page.active {
          display: block;
        }
      </style>

      <!-- Loader Page -->
      <div id="loaderPage" class="page active">
        <div style="text-align: center; padding: 80px 20px">
          <div
            style="
              width: 60px;
              height: 60px;
              border: 6px solid #f3f3f3;
              border-top: 6px solid #667eea;
              border-radius: 50%;
              margin: 0 auto 30px;
              animation: spin 1s linear infinite;
            "
          ></div>
          <h2 style="color: #667eea; margin-bottom: 15px">
            Loading Tournament...
          </h2>
          <p style="color: #666">
            Please wait while we fetch the tournament data
          </p>
        </div>
        <div
          style="
            margin-top: 30px;
            padding: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: #999;
            font-size: 0.75em;
            border-top: 1px solid #eee;
          "
        >
          <span class="app-version"></span>
          <span>UTC: <span class="deviceUTC">--</span></span>
        </div>
      </div>

      <!-- Tournament Not Found Page -->
      <div id="notFoundPage" class="page">
        <div style="text-align: center; padding: 60px 20px">
          <div style="font-size: 80px; margin-bottom: 20px">‚ö†Ô∏è</div>
          <h2 style="color: #d32f2f; margin-bottom: 15px">
            Tournament Not Found
          </h2>
          <p style="color: #666; font-size: 1.1em; margin-bottom: 10px">
            The tournament you're looking for doesn't exist or has been deleted.
          </p>
          <p
            id="notFoundTournamentId"
            style="color: #999; font-size: 0.9em; margin-bottom: 30px"
          ></p>
          <button
            onclick="goToHome()"
            class="btn-primary"
            style="padding: 12px 30px; font-size: 1.1em"
          >
            üè† Go to Home
          </button>
        </div>
        <div
          style="
            margin-top: 30px;
            padding: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: #999;
            font-size: 0.75em;
            border-top: 1px solid #eee;
          "
        >
          <span class="app-version"></span>
          <span>UTC: <span class="deviceUTC">--</span></span>
        </div>
      </div>

      <!-- Create Tournament Page (Team Setup) -->
      <div id="createTournamentPage" class="page">
        <!-- NEW Team Setup View (using containerView) -->
        <div id="newTeamSetupContainer"></div>

        <div
          style="
            margin-top: 30px;
            padding: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: #999;
            font-size: 0.75em;
            border-top: 1px solid #eee;
          "
        >
          <span class="app-version"></span>
          <span>UTC: <span class="deviceUTC">--</span></span>
        </div>
      </div>

      <!-- Tournament Detail Page -->
      <div id="tournamentDetailPage" class="page">
        <!-- Header with Date and Admin Controls -->
        <div id="header-admin-controls"></div>
        <script src="UIComponents/headerWithAdminControls.js"></script>
        <script>
          window.addEventListener("DOMContentLoaded", function () {
            const headerContainer = document.getElementById(
              "header-admin-controls"
            );
            if (headerContainer) {
              headerContainer.appendChild(headerWithAdminControls());
            }
          });
        </script>

        <!-- WATCH LIVE Section (dynamically populated, visible to all) -->
        <div id="watchLiveMessageContainer"></div>

        <!-- Tournament Info Message Section (visible to admin only) -->
        <div id="newWhatsappMessageContainer"></div>

        <!-- Matches Section -->
        <div id="matchesContainer"></div>
        <script>
          window.addEventListener("DOMContentLoaded", function () {
            const matchesContainer =
              document.getElementById("matchesContainer");
            if (matchesContainer) {
              matchesContainer.appendChild(matchesView());
            }
          });
        </script>

        <!-- Points Table Section -->
        <div id="pointsTableContainer"></div>
        <script>
          window.addEventListener("DOMContentLoaded", function () {
            const pointsTableContainer = document.getElementById(
              "pointsTableContainer"
            );
            if (pointsTableContainer) {
              pointsTableContainer.appendChild(pointsTableView());
            }
          });
        </script>

        <!-- Leaderboard Section -->
        <div class="section" id="leaderboardSection">
          <h2>Leaderboard</h2>
          <div
            style="
              display: grid;
              grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
              gap: 20px;
            "
          >
            <div
              style="
                background: #fff;
                padding: 15px;
                border-radius: 10px;
                border-left: 4px solid #ffc107;
              "
            >
              <h3 style="color: #ffc107; margin-bottom: 10px">
                ‚öΩ Top Scorers
              </h3>
              <div
                id="topScorers"
                style="max-height: 300px; overflow-y: auto"
              ></div>
            </div>
            <div
              style="
                background: #fff;
                padding: 15px;
                border-radius: 10px;
                border-left: 4px solid #667eea;
              "
            >
              <h3 style="color: #667eea; margin-bottom: 10px">
                üéØ Top Assists
              </h3>
              <div
                id="topAssists"
                style="max-height: 300px; overflow-y: auto"
              ></div>
            </div>
            <div
              style="
                background: #fff;
                padding: 15px;
                border-radius: 10px;
                border-left: 4px solid #dc3545;
              "
            >
              <h3 style="color: #dc3545; margin-bottom: 10px">üò¨ Own Goals</h3>
              <div
                id="ownGoals"
                style="max-height: 300px; overflow-y: auto"
              ></div>
            </div>
            <div
              style="
                background: #fff;
                padding: 15px;
                border-radius: 10px;
                border-left: 4px solid #28a745;
              "
            >
              <h3 style="color: #28a745; margin-bottom: 10px">
                üß§ Keeper Saves
              </h3>
              <div
                id="topKeeper"
                style="max-height: 300px; overflow-y: auto"
              ></div>
            </div>
            <div
              style="
                background: #fff;
                padding: 15px;
                border-radius: 10px;
                border-left: 4px solid #17a2b8;
              "
            >
              <h3 style="color: #17a2b8; margin-bottom: 10px">
                üõ°Ô∏è Clean Sheets (Teams)
              </h3>
              <div
                id="mostCleanSheets"
                style="max-height: 300px; overflow-y: auto"
              ></div>
            </div>
            <div
              style="
                background: #fff;
                padding: 15px;
                border-radius: 10px;
                border-left: 4px solid #d32f2f;
              "
            >
              <h3 style="color: #d32f2f; margin-bottom: 10px">
                üî• Goals Scored (Teams)
              </h3>
              <div
                id="mostGoals"
                style="max-height: 300px; overflow-y: auto"
              ></div>
            </div>
            <div
              style="
                background: #fff;
                padding: 15px;
                border-radius: 10px;
                border-left: 4px solid #ff6b6b;
              "
            >
              <h3 style="color: #ff6b6b; margin-bottom: 10px">
                ‚ö†Ô∏è Goals Conceded (Teams)
              </h3>
              <div
                id="mostConceded"
                style="max-height: 300px; overflow-y: auto"
              ></div>
            </div>
            <div
              style="
                background: #fff;
                padding: 15px;
                border-radius: 10px;
                border-left: 4px solid #6f42c1;
              "
            >
              <h3 style="color: #6f42c1; margin-bottom: 10px">
                üìä Goal Difference (Teams)
              </h3>
              <div
                id="bestGD"
                style="max-height: 300px; overflow-y: auto"
              ></div>
            </div>
          </div>
        </div>

        <!-- Winner Section (dynamically populated) -->
        <div id="winnerSection"></div>

        <!-- Admin Actions (End Tournament & Delete Tournament) -->
        <div
          id="adminActionsSection"
          class="section"
          style="display: none; text-align: center; margin-top: 30px"
        >
          <button
            id="endTournamentBtn"
            style="
              min-width: 250px;
              padding: 12px 30px;
              font-size: 16px;
              margin: 0 8px 15px 8px;
              background: #ff9800;
              color: white;
              border: none;
              border-radius: 8px;
              cursor: pointer;
              font-weight: 600;
            "
            onclick="endTournament()"
          >
            üèÅ End Tournament
          </button>
          <button
            id="deleteTournamentBtn"
            style="
              min-width: 250px;
              padding: 12px 30px;
              font-size: 16px;
              margin: 0 8px 15px 8px;
              background: #c62828;
              color: white;
              border: none;
              border-radius: 8px;
              cursor: pointer;
              font-weight: 600;
            "
            onclick="deleteTournament(currentTournamentId)"
          >
            üóëÔ∏è Delete Tournament
          </button>
        </div>

        <div
          style="
            margin-top: 30px;
            padding: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: #999;
            font-size: 0.75em;
            border-top: 1px solid #eee;
          "
        >
          <span class="app-version"></span>
          <span>UTC: <span class="deviceUTC">--</span></span>
        </div>
      </div>
    </div>

    <!-- Create Admin Password Modal -->
    <script src="UIComponents/adminPasswordModal.js"></script>

    <!-- Create Keeper Selection Modal -->
    <script src="UIComponents/keeperModal.js"></script>

    <!-- Tournament Winner Banner -->
    <script src="UIComponents/tournamentWinnerBanner.js"></script>

    <script>
      window.addEventListener("DOMContentLoaded", function () {
        createAdminPasswordModal();
        createKeeperModal();
      });
    </script>

    <!-- Modal View Component -->
    <script src="UIComponents/modalView.js"></script>

    <!-- Tournament Login Modal -->
    <script src="UIComponents/adminLoginModal.js"></script>
    <script>
      window.addEventListener("DOMContentLoaded", function () {
        createAdminLoginModal();
      });
    </script>

    <!-- Event Recording Modal -->
    <div class="modal" id="eventModal">
      <div class="modal-content">
        <h2 style="margin-bottom: 20px; color: #667eea" id="eventModalTitle">
          Record Event
        </h2>
        <div id="eventModalContent"></div>
        <div style="display: flex; gap: 10px; margin-top: 20px">
          <button
            class="btn-danger"
            style="flex: 1"
            onclick="closeEventModal()"
          >
            Cancel
          </button>
        </div>
      </div>
    </div>

    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore-compat.js"></script>

    <!-- Configuration Constants -->
    <script src="js/config.js"></script>
    <script src="js/utils.js"></script>
    <script src="js/tournamentSummary.js"></script>

    <!-- UI Components -->
    <script src="UIComponents/headerView.js"></script>
    <script src="UIComponents/containerView.js"></script>
    <script src="UIComponents/teamCardView.js"></script>
    <script src="UIComponents/teamSetupView.js"></script>
    <script src="UIComponents/pointsTableView.js"></script>
    <script src="UIComponents/matches.js"></script>
    <script src="UIComponents/whatsappMessageView.js"></script>

    <!-- Firebase Configuration (update with your credentials) -->
    <script src="js/firebase-config.js"></script>

    <!-- Firebase Storage Manager -->
    <script src="js/firebase-storage.js"></script>

    <!-- Player Database Service -->
    <script src="js/player-database.js"></script>

    <script>
      let teams = {
        red: { name: "Red", players: [], color: "#d32f2f", emoji: "üî¥" },
        black: { name: "Black", players: [], color: "#424242", emoji: "‚ö´" },
        white: { name: "White", players: [], color: "#9e9e9e", emoji: "‚ö™" },
      };

      let standings = {
        red: { played: 0, won: 0, drawn: 0, lost: 0, gf: 0, ga: 0, points: 0 },
        black: {
          played: 0,
          won: 0,
          drawn: 0,
          lost: 0,
          gf: 0,
          ga: 0,
          points: 0,
        },
        white: {
          played: 0,
          won: 0,
          drawn: 0,
          lost: 0,
          gf: 0,
          ga: 0,
          points: 0,
        },
      };

      let matches = [];
      let currentRound = 1;
      let currentMatchForKeeper = null;
      let currentEventMatch = null;
      let currentEventType = null;
      let eventStep = 0;
      let eventData = {};
      let playerStats = {};
      let keeperStats = {};
      let tiebreakerTeams = null;
      let tournamentDate = null;
      let adminPassword = null;
      let isAdmin = false;
      let currentTournamentId = null;
      let allTournaments = {};
      let isTestMode = false;

      // Global timer tracking
      let matchTimers = {}; // { matchId: { startTime: timestamp, interval: intervalId } }

      // Flag to track if page has been reorganized for completed tournament
      let pageReorganized = false;

      // Flag to track if player database sync is in progress
      let isSyncInProgress = false;

      // Note: CONFIG and COLORS constants are loaded from js/config.js

      // Firebase integration
      let firebaseStorage = null;
      let useFirebase = false;
      let playerDatabaseService = null;

      // Initialize Firebase Storage Manager
      function initializeFirebase() {
        try {
          if (
            typeof firebase !== "undefined" &&
            typeof FirebaseStorageManager !== "undefined"
          ) {
            firebaseStorage = new FirebaseStorageManager();
            if (firebaseStorage.initialize()) {
              useFirebase = true;
              // Initialize Player Database Service
              playerDatabaseService = new PlayerDatabaseService(
                firebaseStorage
              );
              console.log("‚úÖ Using Firebase for storage");
              return true;
            }
          }
        } catch (e) {
          console.warn(
            "‚ö†Ô∏è Firebase not available, falling back to localStorage:",
            e
          );
        }

        useFirebase = false;
        console.log("üì¶ Using localStorage for storage");
        return false;
      }

      // Tournament management functions
      function generateTournamentId(isTest = false) {
        const prefix = isTest ? "test_tournament_" : "tournament_";
        return (
          prefix + Date.now() + "_" + Math.random().toString(36).substr(2, 9)
        );
      }

      async function loadTournamentsFromStorage() {
        if (useFirebase && firebaseStorage) {
          console.log("Loading tournaments from Firebase...");
          try {
            allTournaments = await firebaseStorage.loadTournaments();
            console.log("Loaded from Firebase:", allTournaments);
          } catch (e) {
            console.error("Error loading from Firebase:", e);
            allTournaments = {};
          }
        } else {
          console.log("Loading tournaments from localStorage...");
          allTournaments = Utils.safeLoadFromLocalStorage(
            "footballTournaments",
            {}
          );
          console.log("Successfully loaded tournaments:", allTournaments);
        }
      }

      async function saveTournamentToStorage() {
        if (useFirebase && firebaseStorage && currentTournamentId) {
          try {
            await firebaseStorage.saveTournament(
              currentTournamentId,
              allTournaments[currentTournamentId]
            );
            console.log("‚úÖ Saved to Firebase");
          } catch (e) {
            console.error("Error saving to Firebase:", e);
          }
        } else {
          const success = Utils.safeSaveToLocalStorage(
            "footballTournaments",
            allTournaments
          );
          if (success) {
            console.log("‚úÖ Saved to localStorage");
          }
        }
      }

      function getTournamentShareLink(tournamentId) {
        return (
          window.location.href.split("?")[0] + "?tournament=" + tournamentId
        );
      }

      // Page navigation functions
      function showPage(pageName) {
        // Hide all pages
        document.querySelectorAll(".page").forEach((page) => {
          page.classList.remove("active");
        });

        // Show requested page
        const page = document.getElementById(pageName);
        if (page) {
          page.classList.add("active");
        }
      }

      function goToHome() {
        // Clear URL parameters
        window.history.pushState({}, "", window.location.pathname);
        showPage("createTournamentPage");
      }

      async function loadTournamentFromUrl() {
        const urlParams = new URLSearchParams(window.location.search);
        const tournamentId = urlParams.get("tournament");

        if (tournamentId) {
          console.log("Checking tournament ID:", tournamentId);

          // If using Firebase, try to load directly from Firestore
          if (useFirebase && firebaseStorage) {
            try {
              const tournamentData = await firebaseStorage.getTournament(
                tournamentId
              );
              if (tournamentData) {
                allTournaments[tournamentId] = tournamentData;
                console.log(
                  "‚úÖ Loaded tournament from Firebase:",
                  tournamentId
                );
                loadTournament(tournamentId);

                // Set up real-time listener for Firebase
                setupFirebaseListener(tournamentId);
                showPage("tournamentDetailPage");
                return true;
              }
            } catch (e) {
              console.error("Error loading from Firebase:", e);
            }
          }

          // Fallback to checking loaded tournaments
          console.log("Available tournaments:", Object.keys(allTournaments));

          if (allTournaments[tournamentId]) {
            console.log("‚úÖ Loading tournament:", tournamentId);
            loadTournament(tournamentId);

            // Set up real-time listener for Firebase
            if (useFirebase && firebaseStorage) {
              setupFirebaseListener(tournamentId);
            }
            showPage("tournamentDetailPage");
            return true;
          } else {
            console.error("‚ùå Tournament not found in storage!");
            console.error("Requested ID:", tournamentId);
            console.error("Available IDs:", Object.keys(allTournaments));

            // Show not found page
            document.getElementById(
              "notFoundTournamentId"
            ).innerHTML = `Tournament ID: <code style="background: #f5f5f5; padding: 2px 8px; border-radius: 3px;">${tournamentId}</code>`;
            showPage("notFoundPage");
            return false;
          }
        }
        return false;
      }

      // Setup Firebase real-time listener
      function setupFirebaseListener(tournamentId) {
        if (!useFirebase || !firebaseStorage) return;

        console.log("üî• Setting up Firebase real-time listener...");
        firebaseStorage.listenToTournament(tournamentId, (updatedData) => {
          if (updatedData && currentTournamentId === tournamentId) {
            console.log("üî• Tournament updated from Firebase!");

            // Update local data
            allTournaments[tournamentId] = updatedData;

            // Reload tournament UI
            teams = updatedData.teams;
            matches = updatedData.matches;
            standings = updatedData.standings;
            playerStats = updatedData.playerStats || {};
            keeperStats = updatedData.keeperStats || {};

            // Restart timers for any live matches that don't have them
            restartLiveMatchTimers();

            // Re-render UI
            renderMatches();
            updateTable();
            updateLeaderboard();
          }
        });
      }

      function loadTournament(tournamentId) {
        const tournament = allTournaments[tournamentId];
        if (!tournament) {
          console.error(
            "Tournament not found in allTournaments:",
            tournamentId
          );
          return;
        }

        console.log("Loading tournament data:", tournament);

        currentTournamentId = tournamentId;
        teams = tournament.teams;
        matches = tournament.matches;
        standings = tournament.standings;
        tournamentDate = tournament.date;
        adminPassword = tournament.adminPassword;
        playerStats = tournament.playerStats || {};
        keeperStats = tournament.keeperStats || {};

        // Load isTestMode from tournament data, or infer from tournament ID prefix
        if (tournament.hasOwnProperty("isTestMode")) {
          isTestMode = tournament.isTestMode;
        } else {
          // Fallback: Check if tournament ID starts with "test_tournament_"
          isTestMode = tournamentId.startsWith("test_tournament_");
        }

        console.log(
          "Tournament isTestMode flag:",
          isTestMode,
          "(Tournament ID:",
          tournamentId,
          ")"
        );

        // Check if admin session exists for this tournament
        const isAdminSession =
          sessionStorage.getItem(`admin_${tournamentId}`) === "true";
        if (isAdminSession) {
          isAdmin = true;
          console.log("Admin session restored");
        } else {
          isAdmin = false;
        }

        console.log("Tournament data loaded into variables");
        console.log("Teams:", teams);
        console.log("Matches:", matches.length);

        // Update UI - tournament sections are already visible in the page
        console.log("Updating tournament UI...");
        Utils.safeSetText("dateText", tournamentDate);
        updateTournamentStatus();

        // Show admin status or login button based on session
        if (isAdmin) {
          Utils.safeSetStyle("adminControls", "display", "none");
          Utils.safeSetStyle("adminStatus", "display", "block");
          // Show admin-only sections
          const adminSection = Utils.safeGetElement("adminActionsSection");
          if (adminSection) {
            adminSection.style.display = "block";
            // Set up delete button with correct tournament ID
            const deleteBtn = Utils.safeGetElement("deleteTournamentBtn");
            if (deleteBtn) {
              deleteBtn.onclick = () => deleteTournament(currentTournamentId);
            }
            // Hide End Tournament button if tournament has already ended or completed
            const endBtn = Utils.safeGetElement("endTournamentBtn");
            if (endBtn && (isTournamentEnded() || isTournamentComplete())) {
              endBtn.style.display = "none";
            }
          }
          const newWhatsappContainer = Utils.safeGetElement(
            "newWhatsappMessageContainer"
          );
          if (newWhatsappContainer)
            newWhatsappContainer.style.display = "block";
        } else {
          Utils.safeSetStyle("adminControls", "display", "block");
          Utils.safeSetStyle("adminStatus", "display", "none");
          // Hide admin-only sections
          const adminSection = document.getElementById("adminActionsSection");
          if (adminSection) {
            adminSection.style.display = "none";
          }
          const newWhatsappContainer = document.getElementById(
            "newWhatsappMessageContainer"
          );
          if (newWhatsappContainer) {
            newWhatsappContainer.style.display = "none";
          }
        }

        console.log("Showing WATCH LIVE message...");
        // Show WATCH LIVE message
        showWatchLiveMessage();

        // Populate the new WhatsApp message view (visible to admin only)
        populateNewWhatsAppMessageView();

        console.log("Rendering tournament data...");
        // Render all the tournament data
        renderMatches();
        updateTable();
        updateLeaderboard();

        // Also render the team players in case we need to see them
        renderPlayers("red");
        renderPlayers("black");
        renderPlayers("white");

        // Restart intervals for live matches
        restartLiveMatchTimers();

        console.log("Tournament loaded successfully!");
      }

      /**
       * End the tournament manually
       * - Ends any ongoing matches
       * - Marks pending league matches as ABANDONED
       * - Marks final match as ABANDONED if it exists and is pending
       * - Declares league winner as tournament winner if all league matches are done
       * - No winner if any league match is pending
       */
      function endTournament() {
        if (!checkAdmin()) return;

        if (
          !confirm(
            "Are you sure you want to end this tournament?\n\nThis will:\n- End any ongoing matches\n- Mark pending matches as ABANDONED\n- Determine the tournament winner based on completed matches"
          )
        ) {
          return;
        }

        console.log("üèÅ Ending tournament...");

        // 1. End any ongoing matches
        const ongoingMatches = matches.filter((m) => m.status === "live");
        ongoingMatches.forEach((match) => {
          console.log(
            `‚èπÔ∏è Ending ongoing match: ${teams[match.team1].name} vs ${
              teams[match.team2].name
            }`
          );
          endMatch(match.id);
        });

        // 2. Mark pending league matches as ABANDONED
        const pendingLeagueMatches = matches.filter(
          (m) => m.round !== "final" && m.status === "pending"
        );
        pendingLeagueMatches.forEach((match) => {
          console.log(
            `‚ùå Abandoning league match: ${teams[match.team1].name} vs ${
              teams[match.team2].name
            }`
          );
          match.status = "ABANDONED";
        });

        // 3. Check if final match exists and mark as ABANDONED if pending
        const finalMatch = matches.find((m) => m.round === "final");
        if (finalMatch && finalMatch.status === "pending") {
          console.log("‚ùå Abandoning final match");
          finalMatch.status = "ABANDONED";
        }

        // 4. Determine tournament winner
        const leagueMatches = matches.filter((m) => m.round !== "final");
        const allLeagueMatchesCompleted = leagueMatches.every(
          (m) => m.status === "completed"
        );

        if (!allLeagueMatchesCompleted) {
          console.log(
            "‚ö†Ô∏è No tournament winner - Not all league matches were completed"
          );
          alert(
            "Tournament ended.\n\n‚ö†Ô∏è No tournament winner declared because some league matches were not completed."
          );
        } else {
          // All league matches are done, determine winner from standings
          if (!finalMatch || finalMatch.status !== "completed") {
            // Final was not played or not completed, league winner is tournament winner
            const sortedTeams = Object.keys(standings).sort((a, b) => {
              if (standings[b].points !== standings[a].points) {
                return standings[b].points - standings[a].points;
              }
              const gdA = standings[a].gf - standings[a].ga;
              const gdB = standings[b].gf - standings[b].ga;
              if (gdB !== gdA) return gdB - gdA;
              return standings[b].gf - standings[a].gf;
            });

            const winnerTeamKey = sortedTeams[0];
            const winnerTeam = teams[winnerTeamKey];

            console.log(
              `üèÜ Tournament winner: ${winnerTeam.name} Team (League Winner)`
            );
            alert(
              `Tournament ended.\n\nüèÜ Tournament Winner: ${winnerTeam.name} Team\n(Winner of the league stage)`
            );
          } else {
            // Final was completed
            console.log("‚úÖ Tournament ended with final match completed");
            alert(
              "Tournament ended.\n\n‚úÖ Winner already determined from final match."
            );
          }
        }

        // Save changes
        updateTournamentStorage();
        renderMatches();
        updateTable();
        updateLeaderboard();

        // Hide the End Tournament button
        const endTournamentBtn = document.getElementById("endTournamentBtn");
        if (endTournamentBtn) {
          endTournamentBtn.style.display = "none";
        }

        // Sync stats to player database
        syncPlayerDatabase();

        console.log("‚úÖ Tournament ended");
      }

      async function deleteTournament(tournamentId) {
        if (
          confirm(
            "Are you sure you want to delete this tournament? This action cannot be undone."
          )
        ) {
          delete allTournaments[tournamentId];

          // Delete from Firebase if using Firebase
          if (useFirebase && firebaseStorage) {
            try {
              await firebaseStorage.deleteTournament(tournamentId);
              console.log("‚úÖ Deleted from Firebase");
            } catch (e) {
              console.error("Error deleting from Firebase:", e);
            }
          }

          // Also save to localStorage to update the local copy
          Utils.safeSaveToLocalStorage("footballTournaments", allTournaments);
          console.log("‚úÖ Deleted from localStorage");
          if (currentTournamentId === tournamentId) {
            // Reset to setup page
            location.href = location.href.split("?")[0];
          }
          alert("Tournament deleted successfully.");
        }
      }

      function showWatchLiveMessage() {
        // Show WATCH LIVE message to everyone (not just admins)
        if (!currentTournamentId) {
          return;
        }

        const shareLink = getTournamentShareLink(currentTournamentId);
        const watchLiveContainer = document.getElementById(
          "watchLiveMessageContainer"
        );

        if (!watchLiveContainer || !window.whatsappMessageView) return;

        // Clear existing content
        watchLiveContainer.innerHTML = "";

        // Use the whatsappMessageView component
        const viewElement = window.whatsappMessageView({
          icon: "üì∫",
          title: "Watch Live",
          subtitle: "Share this link to let others watch the tournament:",
          message: shareLink,
          buttonTitle: "üìã Copy Link",
        });

        watchLiveContainer.appendChild(viewElement);
      }

      // Initialize tournaments on page load
      window.addEventListener("DOMContentLoaded", async function () {
        console.log("=== TOURNAMENT MANAGER INITIALIZATION ===");
        console.log("Current URL:", window.location.href);
        console.log("URL Search params:", window.location.search);

        // Always show loader page first
        showPage("loaderPage");

        // Start UTC time display immediately
        updateDeviceUTC();
        setInterval(updateDeviceUTC, CONFIG.UTC_CLOCK_INTERVAL);

        // Get tournament ID from URL if present
        const urlParams = new URLSearchParams(window.location.search);
        const tournamentId = urlParams.get("tournament");

        console.log("Tournament ID from URL:", tournamentId);

        // Initialize Firebase
        initializeFirebase();

        // Load tournaments from storage first
        await loadTournamentsFromStorage();
        console.log(
          "Tournaments loaded from storage:",
          Object.keys(allTournaments)
        );

        // Check if we're loading a specific tournament from URL
        if (tournamentId) {
          const loaded = await loadTournamentFromUrl();

          if (!loaded) {
            // Tournament not found - show not found page
            console.log("Tournament not found, showing error page");
            // loadTournamentFromUrl already showed the not found page
          }
          // If loaded successfully, loadTournamentFromUrl already showed tournamentDetailPage

          // If not using Firebase, start localStorage polling
          if (loaded && !useFirebase) {
            startRealTimeSync();
          }
        } else {
          // No tournament ID - show create tournament page
          console.log("No tournament to load, showing create page");
          showPage("createTournamentPage");
        }
      });

      // Update device UTC time display
      function updateDeviceUTC() {
        const utcElements = document.querySelectorAll(".deviceUTC");
        if (utcElements.length > 0) {
          const now = new Date();
          const hours = now.getUTCHours().toString().padStart(2, "0");
          const minutes = now.getUTCMinutes().toString().padStart(2, "0");
          const seconds = now.getUTCSeconds().toString().padStart(2, "0");
          const timeString = `${hours}:${minutes}:${seconds}`;
          utcElements.forEach((el) => {
            el.textContent = timeString;
          });
        }
      }

      // Cleanup on page unload
      window.addEventListener("beforeunload", function (e) {
        // Warn user if player database sync is in progress
        if (isSyncInProgress) {
          e.preventDefault();
          e.returnValue =
            "Player stats are still being saved to the database. Please wait for the sync to complete before closing.";
          return e.returnValue;
        }

        stopRealTimeSync();

        // Stop Firebase listeners
        if (useFirebase && firebaseStorage) {
          firebaseStorage.stopAllListeners();
        }
      });

      // Real-time synchronization
      let syncInterval = null;
      let lastSyncTime = Date.now();

      function startRealTimeSync() {
        if (!currentTournamentId) return;

        console.log(
          "üîÑ Starting real-time sync for tournament:",
          currentTournamentId
        );

        // Listen for storage changes (works across tabs in same browser)
        window.addEventListener("storage", function (e) {
          if (e.key === "footballTournaments" && currentTournamentId) {
            console.log("üì° Storage event detected - tournament updated");
            reloadTournamentData();
          }
        });

        // Poll for updates using configured interval
        syncInterval = setInterval(function () {
          if (currentTournamentId) {
            reloadTournamentData();
          }
        }, CONFIG.STORAGE_POLL_INTERVAL);

        console.log(
          `‚úÖ Real-time sync started (polling every ${CONFIG.STORAGE_POLL_INTERVAL}ms)`
        );
      }

      function stopRealTimeSync() {
        if (syncInterval) {
          clearInterval(syncInterval);
          syncInterval = null;
          console.log("üõë Real-time sync stopped");
        }
      }

      function reloadTournamentData() {
        // Reload tournaments from localStorage
        loadTournamentsFromStorage();

        // Get the current tournament
        const tournament = allTournaments[currentTournamentId];
        if (!tournament) {
          console.warn("Tournament no longer exists");
          return;
        }

        // Check if there are actual changes (including standings)
        const currentDataString = JSON.stringify({
          matches: matches,
          teams: teams,
          standings: standings,
          playerStats: playerStats,
          keeperStats: keeperStats,
        });

        const newDataString = JSON.stringify({
          matches: tournament.matches,
          teams: tournament.teams,
          standings: tournament.standings,
          playerStats: tournament.playerStats,
          keeperStats: tournament.keeperStats,
        });

        // Only update if data has changed
        if (currentDataString !== newDataString) {
          console.log("üîÑ Tournament data changed - updating UI");

          // Update tournament data
          teams = tournament.teams;
          matches = tournament.matches;
          standings = tournament.standings;
          playerStats = tournament.playerStats || {};
          keeperStats = tournament.keeperStats || {};

          // Re-render all views
          renderMatches();
          updateTable();
          updateLeaderboard();

          lastSyncTime = Date.now();
        }

        // Always update timers for live matches (even if no other changes)
        updateLiveMatchTimers();
      }

      function updateLiveMatchTimers() {
        // Only manage intervals: start for live matches, stop for completed matches
        // Each device calculates timer independently from UTC timestamps
        matches.forEach((match) => {
          if (match.status === "live" && match.startTimeUTC) {
            // Ensure interval is running for live match
            if (!matchTimers[match.id]) {
              console.log(
                `Starting missing interval for live match ${match.id} (sync)`
              );
              startCountdownTimer(match.id);
            }
          } else if (match.status === "completed" && matchTimers[match.id]) {
            // Match was completed, stop the timer
            console.log(
              `Stopping timer for completed match ${match.id} (localStorage sync)`
            );
            clearInterval(matchTimers[match.id]);
            delete matchTimers[match.id];
          }
        });
      }

      function addPlayer(team) {
        const input = document.getElementById(`${team}PlayerInput`);
        const name = input.value.trim();

        if (!name) {
          alert("Please enter a player name");
          return;
        }

        if (teams[team].players.length >= 5) {
          alert("Maximum 5 players per team");
          return;
        }

        teams[team].players.push(name);
        const playerId = `${team}-${name}`;
        playerStats[playerId] = {
          name: name,
          team: team,
          goals: 0,
          assists: 0,
          ownGoals: 0,
        };
        keeperStats[playerId] = {
          name: name,
          team: team,
          saves: 0,
          cleanSheets: 0,
        };
        input.value = "";
        renderPlayers(team);
      }

      function removePlayer(team, index) {
        const playerName = teams[team].players[index];
        const playerId = `${team}-${playerName}`;
        delete playerStats[playerId];
        delete keeperStats[playerId];
        teams[team].players.splice(index, 1);
        renderPlayers(team);
      }

      function renderPlayers(team) {
        const container = document.getElementById(`${team}Players`);
        container.innerHTML = teams[team].players
          .map(
            (player, idx) => `
                <div class="player-item">
                    <span>${player}</span>
                    <button class="remove-btn" onclick="removePlayer('${team}', ${idx})" style="background: none; border: none; font-size: 20px; font-weight: bold; color: #333; cursor: pointer; padding: 4px 8px;">‚úï</button>
                </div>
            `
          )
          .join("");
      }

      function addTestPlayers() {
        isTestMode = true;
        teams.red.players = ["Marcus", "Diego", "Andre", "Carlo", "Sergio"];
        teams.black.players = ["Kevin", "Raheem", "Jack", "Phil", "Kyle"];
        teams.white.players = ["Bruno", "Paul", "Harry", "Luke", "Aaron"];

        playerStats = {};
        keeperStats = {};

        ["red", "black", "white"].forEach((team) => {
          teams[team].players.forEach((name) => {
            const playerId = `${team}-${name}`;
            playerStats[playerId] = {
              name: name,
              team: team,
              goals: 0,
              assists: 0,
              ownGoals: 0,
            };
            keeperStats[playerId] = {
              name: name,
              team: team,
              saves: 0,
              cleanSheets: 0,
            };
          });
        });

        renderPlayers("red");
        renderPlayers("black");
        renderPlayers("white");
      }

      function startTournament() {
        for (let team in teams) {
          if (teams[team].players.length === 0) {
            alert(`Please add at least one player to ${teams[team].name} team`);
            return;
          }
        }

        // Show admin password modal
        document.getElementById("adminPasswordModal").style.display = "flex";
      }

      function setAdminPassword() {
        const password = Utils.safeGetValue("adminPasswordInput");
        const confirm = Utils.safeGetValue("adminPasswordConfirm");
        const superUserCode = Utils.safeGetValue("superUserCodeInput");

        // Check Super User Code if not in test mode
        if (!isTestMode) {
          if (!superUserCode) {
            alert("Please enter a Super User Code to start a tournament");
            return;
          }

          if (!CONFIG.SUPER_USER_CODES.includes(superUserCode)) {
            alert("Invalid Super User Code");
            return;
          }
        }

        if (!password || password.length < 4) {
          alert("Password must be at least 4 characters long");
          return;
        }

        if (password !== confirm) {
          alert("Passwords do not match");
          return;
        }

        adminPassword = password;
        isAdmin = true;
        Utils.safeSetStyle("adminPasswordModal", "display", "none");

        // Generate unique tournament ID (with test prefix if test mode)
        currentTournamentId = generateTournamentId(isTestMode);

        // Store admin session for this tournament
        sessionStorage.setItem(`admin_${currentTournamentId}`, "true");

        const now = new Date();
        tournamentDate = now.toLocaleDateString("en-GB", {
          day: "2-digit",
          month: "short",
          year: "numeric",
        });

        matches = [];

        // Kick-off distribution pattern to ensure each team gets equal chances
        // Matches in each round: R vs B, R vs W, B vs W
        // Pattern ensures each team gets 3 kick-offs across 9 matches
        // Round 1: red (R vs B), white (R vs W), black (B vs W)
        // Round 2: black (R vs B), red (R vs W), white (B vs W)
        // Round 3: red (R vs B), white (R vs W), black (B vs W) - Repeats Round 1
        const kickoffPattern = [
          ["red", "white", "black"], // Round 1: R vs B (red), R vs W (white), B vs W (black)
          ["black", "red", "white"], // Round 2: R vs B (black), R vs W (red), B vs W (white)
          ["red", "white", "black"], // Round 3: R vs B (red), R vs W (white), B vs W (black) - Same as Round 1
        ];

        for (let round = 1; round <= 3; round++) {
          const roundKickoffs = kickoffPattern[round - 1];

          matches.push({
            id: matches.length,
            round: round,
            team1: "red",
            team2: "black",
            score1: 0,
            score2: 0,
            status: "pending",
            startTimeUTC: null,
            endTimeUTC: null,
            goals: [],
            keeper1: null,
            keeper2: null,
            kickoffTeam: roundKickoffs[0],
          });

          matches.push({
            id: matches.length,
            round: round,
            team1: "red",
            team2: "white",
            score1: 0,
            score2: 0,
            status: "pending",
            startTimeUTC: null,
            endTimeUTC: null,
            goals: [],
            keeper1: null,
            keeper2: null,
            kickoffTeam: roundKickoffs[1],
          });

          matches.push({
            id: matches.length,
            round: round,
            team1: "black",
            team2: "white",
            score1: 0,
            score2: 0,
            status: "pending",
            startTimeUTC: null,
            endTimeUTC: null,
            goals: [],
            keeper1: null,
            keeper2: null,
            kickoffTeam: roundKickoffs[2],
          });
        }

        // Save tournament to storage
        allTournaments[currentTournamentId] = {
          id: currentTournamentId,
          teams: JSON.parse(JSON.stringify(teams)),
          matches: JSON.parse(JSON.stringify(matches)),
          standings: JSON.parse(JSON.stringify(standings)),
          date: tournamentDate,
          adminPassword: adminPassword,
          playerStats: JSON.parse(JSON.stringify(playerStats)),
          keeperStats: JSON.parse(JSON.stringify(keeperStats)),
          created: new Date().toISOString(),
          isTestMode: isTestMode,
        };
        console.log("Saving tournament to storage:", currentTournamentId);
        console.log("Tournament data:", allTournaments[currentTournamentId]);
        saveTournamentToStorage();
        console.log("Tournament saved to localStorage");

        // Update URL to include tournament ID
        const newUrl = getTournamentShareLink(currentTournamentId);
        window.history.pushState({}, "", newUrl);

        // Load the tournament (which will switch to tournament detail page)
        loadTournament(currentTournamentId);

        // Show the tournament detail page
        showPage("tournamentDetailPage");

        // Show WATCH LIVE message
        showWatchLiveMessage();

        populateNewWhatsAppMessageView();
        renderMatches();
        updateTable();
        updateLeaderboard();
      }

      function showAdminLogin() {
        document.getElementById("adminLoginModal").style.display = "flex";
      }

      function closeAdminLogin() {
        document.getElementById("adminLoginModal").style.display = "none";
        document.getElementById("adminLoginInput").value = "";
      }

      function verifyAdminLogin() {
        const enteredPassword = Utils.safeGetValue("adminLoginInput");

        if (enteredPassword === adminPassword) {
          isAdmin = true;

          // Store admin session for this tournament
          sessionStorage.setItem(`admin_${currentTournamentId}`, "true");

          Utils.safeSetStyle("adminLoginModal", "display", "none");
          const loginInput = Utils.safeGetElement("adminLoginInput");
          if (loginInput) loginInput.value = "";
          Utils.safeSetStyle("adminControls", "display", "none");
          Utils.safeSetStyle("adminStatus", "display", "block");

          // Show admin-only sections (check if they exist)
          const adminSection = document.getElementById("adminActionsSection");
          if (adminSection) {
            adminSection.style.display = "block";
            const deleteBtn = document.getElementById("deleteTournamentBtn");
            if (deleteBtn) {
              deleteBtn.onclick = () => deleteTournament(currentTournamentId);
            }
          }

          const newWhatsappContainer = document.getElementById(
            "newWhatsappMessageContainer"
          );
          if (newWhatsappContainer) {
            newWhatsappContainer.style.display = "block";
          }

          // If tournament is complete, show tournament summary section
          if (isTournamentComplete()) {
            // Tournament is complete, reorganize the page with admin privileges
            pageReorganized = false;
            reorganizePageForCompletedTournament();
          }

          // Show admin-only elements
          showWatchLiveMessage();

          // Re-render matches to show admin controls
          renderMatches();
          // No success alert - just login smoothly
        } else {
          alert("Incorrect password");
        }
      }

      async function updateTournamentStorage() {
        if (currentTournamentId && allTournaments[currentTournamentId]) {
          console.log(
            "Saving matches to storage:",
            matches.map((m) => ({
              id: m.id,
              status: m.status,
              startTimeUTC: m.startTimeUTC,
              endTimeUTC: m.endTimeUTC,
            }))
          );

          allTournaments[currentTournamentId].teams = JSON.parse(
            JSON.stringify(teams)
          );
          allTournaments[currentTournamentId].matches = JSON.parse(
            JSON.stringify(matches)
          );
          allTournaments[currentTournamentId].standings = JSON.parse(
            JSON.stringify(standings)
          );
          allTournaments[currentTournamentId].playerStats = JSON.parse(
            JSON.stringify(playerStats)
          );
          allTournaments[currentTournamentId].keeperStats = JSON.parse(
            JSON.stringify(keeperStats)
          );
          await saveTournamentToStorage();
        }
      }

      function logoutAdmin() {
        isAdmin = false;

        // Clear admin session
        if (currentTournamentId) {
          sessionStorage.removeItem(`admin_${currentTournamentId}`);
        }

        // Hide admin-only sections
        const adminSection = Utils.safeGetElement("adminActionsSection");
        if (adminSection) {
          adminSection.style.display = "none";
        }

        const newWhatsappContainer = document.getElementById(
          "newWhatsappMessageContainer"
        );
        if (newWhatsappContainer) {
          newWhatsappContainer.style.display = "none";
        }

        Utils.safeSetStyle("adminStatus", "display", "none");
        Utils.safeSetStyle("adminControls", "display", "block");

        // Reset the page reorganization flag and reload
        pageReorganized = false;

        renderMatches();
      }

      function checkAdmin() {
        if (!isAdmin) {
          alert(
            "Admin access required. Please login to manage the tournament."
          );
          return false;
        }
        return true;
      }

      function showKeeperModal(matchId) {
        if (!checkAdmin()) return;

        currentMatchForKeeper = matchId;
        const match = matches.find((m) => m.id === matchId);
        const modal = document.getElementById("keeperModal");
        const content = document.getElementById("keeperSelectionContent");

        content.innerHTML = `
                <div style="margin-bottom: 16px">
                    <h3 style="color: ${
                      teams[match.team1].color
                    }; margin: 0 0 8px 0; font-weight: bold;">${
          teams[match.team1].name
        } Goalkeeper</h3>
                    <select id="keeper1Select" style="width: 100%; padding: 12px; padding-right: 40px; border: 2px solid #667eea; border-radius: 4px; font-size: 16px;">
                        ${teams[match.team1].players
                          .map((p) => `<option value="${p}">${p}</option>`)
                          .join("")}
                    </select>
                </div>
                <div style="margin-bottom: 16px">
                    <h3 style="color: ${
                      teams[match.team2].color
                    }; margin: 0 0 8px 0; font-weight: bold;">${
          teams[match.team2].name
        } Goalkeeper</h3>
                    <select id="keeper2Select" style="width: 100%; padding: 12px; padding-right: 40px; border: 2px solid #667eea; border-radius: 4px; font-size: 16px;">
                        ${teams[match.team2].players
                          .map((p) => `<option value="${p}">${p}</option>`)
                          .join("")}
                    </select>
                </div>
            `;

        modal.style.display = "flex";
      }

      function confirmKeepers() {
        const match = matches.find((m) => m.id === currentMatchForKeeper);
        match.keeper1 = document.getElementById("keeper1Select").value;
        match.keeper2 = document.getElementById("keeper2Select").value;

        document.getElementById("keeperModal").style.display = "none";
        startMatch(currentMatchForKeeper);
      }

      /**
       * Generate match card HTML
       * Centralized function to create consistent match cards throughout the app
       * @param {Object} match - The match object
       * @param {Object} options - Options for rendering
       * @param {boolean} options.showControls - Show admin controls (default: true if admin)
       * @param {boolean} options.isFinal - Is this the final match (default: auto-detect)
       * @returns {string} Match card HTML
       */

      // Helper function to get team color emoji
      function getTeamColorEmoji(teamKey) {
        const emojiMap = {
          red: "üî¥",
          black: "‚ö´",
          white: "‚ö™",
        };
        return emojiMap[teamKey] || "‚öΩ";
      }

      function createMatchCardHTML(match, options = {}) {
        const { showControls = isAdmin, isFinal = match.round === "final" } =
          options;

        // Check if any match is currently live
        const hasLiveMatch = matches.some((m) => m.status === "live");

        // Debug: Log isTestMode value when rendering match cards
        if (match.status === "live") {
          console.log(
            `Rendering match ${match.id} - isTestMode: ${isTestMode}`
          );
        }

        // Calculate timer display
        let timerDisplay = "10:00";
        if (
          match.status === "completed" &&
          match.startTimeUTC &&
          match.endTimeUTC
        ) {
          const startTime = new Date(match.startTimeUTC).getTime();
          const endTime = new Date(match.endTimeUTC).getTime();
          const elapsedSeconds = Math.floor((endTime - startTime) / 1000);
          const remainingSeconds =
            elapsedSeconds >= CONFIG.MATCH_DURATION_SECONDS
              ? 0
              : Math.max(0, CONFIG.MATCH_DURATION_SECONDS - elapsedSeconds);
          const mins = Math.floor(remainingSeconds / 60);
          const secs = remainingSeconds % 60;
          timerDisplay = `${mins}:${secs.toString().padStart(2, "0")}`;
        } else if (match.status === "live" && match.startTimeUTC) {
          const startTime = new Date(match.startTimeUTC).getTime();
          const elapsedSeconds = Math.floor((Date.now() - startTime) / 1000);
          const remainingSeconds = Math.min(
            CONFIG.MATCH_DURATION_SECONDS,
            Math.max(0, CONFIG.MATCH_DURATION_SECONDS - elapsedSeconds)
          );
          const mins = Math.floor(remainingSeconds / 60);
          const secs = remainingSeconds % 60;
          timerDisplay = `${mins}:${secs.toString().padStart(2, "0")}`;
        }

        // Determine status color
        const statusColor =
          match.status === "completed"
            ? COLORS.STATUS_COMPLETED
            : match.status === "live"
            ? COLORS.STATUS_LIVE
            : match.status === "ABANDONED"
            ? "#999"
            : COLORS.STATUS_PENDING;

        return `
                <div class="match-card ${
                  isFinal ? "final-match" : ""
                }" id="match-${match.id}">
                    <div class="match-header">
                        <span class="match-header-title">${
                          isFinal
                            ? "üèÜ FINAL"
                            : `Round ${match.round} - Match ${
                                (match.id % 3) + 1
                              }`
                        }</span>
                        <span class="match-header-status">
                            <span style="color: ${statusColor}; font-weight: bold;">
                                ${match.status.toUpperCase()}
                            </span>
                            <span id="timer-${
                              match.id
                            }" style="color: #667eea; font-weight: bold;">${timerDisplay}</span>
                        </span>
                    </div>

                    <div class="match-scoreboard">
                        <div class="team-score-row">
                            <div class="team-info">
                                <div class="team-name" style="color: ${
                                  teams[match.team1].color
                                }">
                                    ${getTeamColorEmoji(match.team1)} ${
          teams[match.team1].name
        }${
          match.kickoffTeam === match.team1
            ? ' <span style="font-size: 0.8em;" title="Has kick-off">üëü‚öΩ</span>'
            : ""
        }
                                </div>
                                ${
                                  match.keeper1
                                    ? `<div class="team-keeper">üß§ ${match.keeper1}</div>`
                                    : ""
                                }
                            </div>
                            <div class="team-score">${match.score1}</div>
                        </div>
                        
                        <div class="team-score-row">
                            <div class="team-info">
                                <div class="team-name" style="color: ${
                                  teams[match.team2].color
                                }">
                                    ${getTeamColorEmoji(match.team2)} ${
          teams[match.team2].name
        }${
          match.kickoffTeam === match.team2
            ? ' <span style="font-size: 0.8em;" title="Has kick-off">üëü‚öΩ</span>'
            : ""
        }
                                </div>
                                ${
                                  match.keeper2
                                    ? `<div class="team-keeper">üß§ ${match.keeper2}</div>`
                                    : ""
                                }
                            </div>
                            <div class="team-score">${match.score2}</div>
                        </div>
                    </div>

                    ${
                      showControls && match.status !== "ABANDONED"
                        ? `
                        <div class="match-controls">
                            ${
                              match.status === "pending" && !hasLiveMatch
                                ? `
                                <button class="btn-success" onclick="showKeeperModal(${match.id})" style="grid-column: 1 / -1;">Start</button>
                            `
                                : ""
                            }
                            
                            ${
                              match.status === "live"
                                ? `
                                <button class="match-action-btn match-btn-goal" onclick="showGoalDialog(${match.id})">
                                    <span class="icon-large">‚öΩ</span>
                                    <span>Add<br>Goal</span>
                                </button>
                                <button class="match-action-btn match-btn-own-goal" onclick="showOwnGoalDialog(${match.id})">
                                    <span class="icon-large">‚ö†Ô∏è</span>
                                    <span>Add<br>Own Goal</span>
                                </button>
                                <button class="match-action-btn" onclick="recordQuickSave(${match.id}, '${match.team1}')" style="background: ${teams[match.team1].color};">
                                    <span class="icon-large">üß§</span>
                                    <span>${teams[match.team1].name}<br>Save</span>
                                </button>
                                <button class="match-action-btn" onclick="recordQuickSave(${match.id}, '${match.team2}')" style="background: ${teams[match.team2].color};">
                                    <span class="icon-large">üß§</span>
                                    <span>${teams[match.team2].name}<br>Save</span>
                                </button>
                                <button class="match-action-btn match-btn-control match-btn-full" onclick="endMatch(${match.id})" style="grid-column: 1 / -1;">
                                    <span class="icon-large">üèÅ</span>
                                    <span>End Match</span>
                                </button>
                                <button class="match-action-btn match-btn-control match-btn-full" onclick="simulateMatch(${match.id})" style="grid-column: 1 / -1;">
                                    <span class="icon-large">üé≤</span>
                                    <span>Random Events</span>
                                </button>
                            `
                                : ""
                            }
                        </div>
                    `
                        : ""
                    }

                    <div class="goal-log" id="goals-${match.id}">
                        ${match.goals
                          .map(
                            (g) => `
                            <div class="goal-item ${
                              g.ownGoal ? "own-goal" : ""
                            } ${g.type === "save" ? "save-item" : ""}">
                                ${g.type === "save" ? "üß§" : "‚öΩ"} ${
                              g.time
                            }' - ${teams[g.team].name} - ${g.scorer}${
                              g.assist ? ` (Assist: ${g.assist})` : ""
                            }${g.ownGoal ? " [OWN GOAL]" : ""}${
                              g.type === "save" ? " [SAVE]" : ""
                            }
                            </div>
                        `
                          )
                          .join("")}
                    </div>
                </div>
            `;
      }

      function renderMatches() {
        const grid = document.getElementById("matchesGrid");

        // When tournament is complete, exclude final match from this grid
        const tournamentComplete = isTournamentComplete();
        const matchesToRender = tournamentComplete
          ? matches.filter((m) => m.round !== "final")
          : matches;

        // Use centralized match card generator
        grid.innerHTML = matchesToRender
          .map((match) => createMatchCardHTML(match))
          .join("");

        // After rendering, immediately update timer displays for all live matches
        // This ensures accurate display even if intervals haven't ticked yet
        matches.forEach((match) => {
          if (match.status === "live" && match.startTimeUTC) {
            const startTime = new Date(match.startTimeUTC).getTime();
            const elapsedSeconds = Math.floor((Date.now() - startTime) / 1000);
            // Clamp between 0 and MATCH_DURATION_SECONDS to handle clock skew
            const remainingSeconds = Math.min(
              CONFIG.MATCH_DURATION_SECONDS,
              Math.max(0, CONFIG.MATCH_DURATION_SECONDS - elapsedSeconds)
            );
            updateTimerDisplay(match.id, remainingSeconds);
          }
        });

        // Check if tournament is complete and reorganize layout
        reorganizePageForCompletedTournament();

        // Update tournament status
        updateTournamentStatus();
      }

      function startMatch(matchId) {
        const match = matches.find((m) => m.id === matchId);
        match.status = "live";
        match.startTimeUTC = new Date().toISOString();
        match.endTimeUTC = null;

        // Start 10-minute countdown timer
        startCountdownTimer(matchId);

        renderMatches();
        updateTournamentStorage();
      }

      function startCountdownTimer(matchId) {
        const match = matches.find((m) => m.id === matchId);
        if (!match || match.status !== "live") return;

        // Calculate how much time has elapsed since start
        const startTime = new Date(match.startTimeUTC).getTime();
        const now = Date.now();
        const elapsedMs = now - startTime;
        const elapsedSeconds = Math.floor(elapsedMs / 1000);

        // Use configured match duration
        const totalSeconds = CONFIG.MATCH_DURATION_SECONDS;
        let remainingSeconds = totalSeconds - elapsedSeconds;

        // Clamp to valid range: 0 to MATCH_DURATION_SECONDS (never exceed max time or go negative)
        if (remainingSeconds < 0) remainingSeconds = 0;
        if (remainingSeconds > CONFIG.MATCH_DURATION_SECONDS)
          remainingSeconds = CONFIG.MATCH_DURATION_SECONDS;

        // Update display immediately
        updateTimerDisplay(matchId, remainingSeconds);

        // Start interval
        matchTimers[matchId] = setInterval(() => {
          const currentElapsed = Math.floor((Date.now() - startTime) / 1000);
          remainingSeconds = totalSeconds - currentElapsed;

          // Clamp to valid range: 0 to MATCH_DURATION_SECONDS (handle clock skew between devices)
          if (remainingSeconds < 0) remainingSeconds = 0;
          if (remainingSeconds > CONFIG.MATCH_DURATION_SECONDS)
            remainingSeconds = CONFIG.MATCH_DURATION_SECONDS;

          if (remainingSeconds <= 0) {
            updateTimerDisplay(matchId, 0);
            // Timer stops at 0:00 but match continues until admin ends it
            clearInterval(matchTimers[matchId]);
            delete matchTimers[matchId];
          } else {
            updateTimerDisplay(matchId, remainingSeconds);
          }
        }, CONFIG.TIMER_UPDATE_INTERVAL);
      }

      function updateTimerDisplay(matchId, seconds) {
        const timerElement = document.getElementById(`timer-${matchId}`);
        if (timerElement) {
          const mins = Math.floor(seconds / 60);
          const secs = seconds % 60;
          timerElement.textContent = `${mins}:${secs
            .toString()
            .padStart(2, "0")}`;
        }
      }

      function restartLiveMatchTimers() {
        // Restart countdown timers for any live matches after page reload
        // AND stop timers for any completed matches
        matches.forEach((match) => {
          if (
            match.status === "live" &&
            match.startTimeUTC &&
            !matchTimers[match.id]
          ) {
            console.log(`Restarting countdown timer for match ${match.id}`);
            startCountdownTimer(match.id);
          } else if (match.status === "completed" && matchTimers[match.id]) {
            // Match was completed (possibly by admin on another device)
            // Stop the timer on this device
            console.log(`Stopping timer for completed match ${match.id}`);
            clearInterval(matchTimers[match.id]);
            delete matchTimers[match.id];
          }
        });
      }

      function togglePause(matchId) {
        if (!checkAdmin()) return;
        alert("Pause functionality temporarily disabled");
      }

      function simulateMatch(matchId) {
        if (!checkAdmin()) return;
        const match = matches.find((m) => m.id === matchId);

        // Keep generating events until a team reaches 3 goals
        while (match.score1 < 3 && match.score2 < 3) {
          // Pick random event: 0 = goal, 1 = own goal, 2 = save
          const eventType = Math.floor(Math.random() * 3);

          if (eventType === 0) {
            // Add Goal
            const scoringTeam = Math.random() > 0.5 ? match.team1 : match.team2;
            const teamPlayers = teams[scoringTeam].players;
            const scorer =
              teamPlayers[Math.floor(Math.random() * teamPlayers.length)];

            // Random assist (50% chance of having an assist)
            const hasAssist = Math.random() > 0.5;
            let assist = "";
            if (hasAssist) {
              const otherPlayers = teamPlayers.filter((p) => p !== scorer);
              if (otherPlayers.length > 0) {
                assist =
                  otherPlayers[Math.floor(Math.random() * otherPlayers.length)];
              }
            }

            const elapsedTime = match.startTimeUTC
              ? Math.floor(
                  (Date.now() - new Date(match.startTimeUTC).getTime()) / 1000
                )
              : 0;
            const minutes = Math.floor(elapsedTime / 60);

            match.goals.push({
              team: scoringTeam,
              scorer: scorer,
              assist: assist,
              ownGoal: false,
              time: minutes,
              type: "goal",
            });

            const scorerId = `${scoringTeam}-${scorer}`;
            playerStats[scorerId].goals++;

            if (assist) {
              const assistId = `${scoringTeam}-${assist}`;
              playerStats[assistId].assists++;
            }

            if (scoringTeam === match.team1) {
              match.score1++;
            } else {
              match.score2++;
            }
          } else if (eventType === 1) {
            // Add Own Goal
            const ownGoalTeam = Math.random() > 0.5 ? match.team1 : match.team2;
            const teamPlayers = teams[ownGoalTeam].players;
            const player =
              teamPlayers[Math.floor(Math.random() * teamPlayers.length)];

            const elapsedTime = match.startTimeUTC
              ? Math.floor(
                  (Date.now() - new Date(match.startTimeUTC).getTime()) / 1000
                )
              : 0;
            const minutes = Math.floor(elapsedTime / 60);

            match.goals.push({
              team: ownGoalTeam,
              scorer: player,
              assist: "",
              ownGoal: true,
              time: minutes,
              type: "goal",
            });

            const playerId = `${ownGoalTeam}-${player}`;
            if (!playerStats[playerId].ownGoals)
              playerStats[playerId].ownGoals = 0;
            playerStats[playerId].ownGoals++;

            // Own goal goes to opponent
            if (ownGoalTeam === match.team1) {
              match.score2++;
            } else {
              match.score1++;
            }
          } else {
            // Add Save
            const saveTeam = Math.random() > 0.5 ? match.team1 : match.team2;
            const keeper =
              saveTeam === match.team1 ? match.keeper1 : match.keeper2;

            const elapsedTime = match.startTimeUTC
              ? Math.floor(
                  (Date.now() - new Date(match.startTimeUTC).getTime()) / 1000
                )
              : 0;
            const minutes = Math.floor(elapsedTime / 60);

            match.goals.push({
              team: saveTeam,
              scorer: keeper,
              assist: "",
              ownGoal: false,
              time: minutes,
              type: "save",
            });

            const keeperId = `${saveTeam}-${keeper}`;
            keeperStats[keeperId].saves++;
          }
        }

        // Match ends when any team reaches 3 goals
        endMatch(matchId);
      }

      /**
       * Sync tournament stats to player database
       * Only runs if not in test mode and Firebase is available
       */
      async function syncPlayerDatabase() {
        // Check if sync is already in progress
        if (isSyncInProgress) {
          console.log(
            "‚è≥ Sync already in progress, skipping duplicate request..."
          );
          return;
        }

        if (isTestMode) {
          console.log("üß™ Test mode: Skipping player database sync");
          return;
        }

        if (!useFirebase || !playerDatabaseService) {
          console.log(
            "‚ö†Ô∏è Firebase not available: Skipping player database sync"
          );
          return;
        }

        // Set flag to prevent concurrent syncs
        isSyncInProgress = true;
        console.log("üîÑ Syncing tournament stats to player database...");

        try {
          // Get final match to determine winners
          const finalMatch = matches.find((m) => m.round === "final");
          let winnerTeam = null;
          let runnerUpTeam = null;

          if (finalMatch) {
            if (finalMatch.score1 > finalMatch.score2) {
              winnerTeam = finalMatch.team1;
              runnerUpTeam = finalMatch.team2;
            } else if (finalMatch.score2 > finalMatch.score1) {
              winnerTeam = finalMatch.team2;
              runnerUpTeam = finalMatch.team1;
            }
          }

          // Process each player
          for (const [playerId, stats] of Object.entries(playerStats)) {
            const playerName = stats.name;
            const teamKey = stats.team;

            // Get or create player
            const player = await playerDatabaseService.getOrCreatePlayer(
              playerName
            );

            if (!player) {
              console.error(`‚ùå Failed to sync player: ${playerName}`);
              continue;
            }

            // Calculate player's game results from league matches
            const teamStandings = standings[teamKey] || {};
            let gamesPlayed = teamStandings.played || 0;
            let gamesWon = teamStandings.won || 0;
            let gamesLost = teamStandings.lost || 0;
            let gamesDrawn = teamStandings.drawn || 0;

            // Check if player was in final and add final match to totals
            let finalsPlayed = 0;
            let finalsWon = 0;
            let finalsLost = 0;

            if (
              finalMatch &&
              (teamKey === finalMatch.team1 || teamKey === finalMatch.team2)
            ) {
              finalsPlayed = 1;
              gamesPlayed += 1; // Add final to total games

              if (teamKey === winnerTeam) {
                finalsWon = 1;
                gamesWon += 1; // Add final win to total wins
              } else if (teamKey === runnerUpTeam) {
                finalsLost = 1;
                gamesLost += 1; // Add final loss to total losses
              } else {
                // Final was a draw
                gamesDrawn += 1;
              }
            }

            // Get keeper stats
            const keeperData = keeperStats[playerId] || {};

            // Prepare stats update
            const statsUpdate = {
              gamesPlayed: gamesPlayed,
              gamesWon: gamesWon,
              gamesLost: gamesLost,
              gamesDrawn: gamesDrawn,
              goals: stats.goals || 0,
              assists: stats.assists || 0,
              saves: keeperData.saves || 0,
              cleanSheets: keeperData.cleanSheets || 0,
              ownGoals: stats.ownGoals || 0,
              finalsPlayed: finalsPlayed,
              finalsWon: finalsWon,
              finalsLost: finalsLost,
            };

            // Update player stats
            await playerDatabaseService.updatePlayerStats(
              player.id,
              statsUpdate,
              currentTournamentId
            );
            console.log(`‚úÖ Synced stats for ${playerName}`);
          }

          console.log("üéâ Player database sync completed!");
        } catch (error) {
          console.error("‚ùå Error syncing player database:", error);
        } finally {
          // Always reset the flag, even if there was an error
          isSyncInProgress = false;
        }
      }

      function endMatch(matchId) {
        if (!checkAdmin()) return;
        const match = matches.find((m) => m.id === matchId);

        // Save end time in UTC
        match.endTimeUTC = new Date().toISOString();
        match.status = "completed";

        // Calculate elapsed time for logging
        if (match.startTimeUTC && match.endTimeUTC) {
          const startTime = new Date(match.startTimeUTC).getTime();
          const endTime = new Date(match.endTimeUTC).getTime();
          const elapsedSeconds = Math.floor((endTime - startTime) / 1000);
          console.log(
            "Match ended - Duration:",
            Math.floor(elapsedSeconds / 60) +
              ":" +
              (elapsedSeconds % 60).toString().padStart(2, "0")
          );
        }

        // Clear the interval
        if (matchTimers[matchId]) {
          clearInterval(matchTimers[matchId]);
          delete matchTimers[matchId];
        }

        const keeper1Id = `${match.team1}-${match.keeper1}`;
        const keeper2Id = `${match.team2}-${match.keeper2}`;

        if (match.score2 === 0) {
          keeperStats[keeper1Id].cleanSheets++;
        }
        if (match.score1 === 0) {
          keeperStats[keeper2Id].cleanSheets++;
        }

        updateStandings(match);

        // Save immediately before rendering to ensure timer is synced
        updateTournamentStorage();

        renderMatches();
        updateTable();
        updateLeaderboard();

        const roundRobinMatches = matches.filter((m) => m.round !== "final");
        const allComplete = roundRobinMatches.every(
          (m) => m.status === "completed"
        );

        if (allComplete && !matches.some((m) => m.round === "final")) {
          createFinal();
        } else if (allComplete && matches.some((m) => m.round === "final")) {
          // Tournament is fully complete (including final)
          syncPlayerDatabase();
        }
        // Hide End Tournament button if final match was just completed
        if (match.round === "final") {
          const endTournamentBtn = document.getElementById("endTournamentBtn");
          if (endTournamentBtn) {
            endTournamentBtn.style.display = "none";
          }
        }
      }

      function showGoalDialog(matchId) {
        if (!checkAdmin()) return;

        currentEventMatch = matchId;
        currentEventType = "goal";
        eventStep = 1;
        eventData = {};
        showEventStep();
      }

      function showOwnGoalDialog(matchId) {
        if (!checkAdmin()) return;

        currentEventMatch = matchId;
        currentEventType = "owngoal";
        eventStep = 1;
        eventData = {};
        showEventStep();
      }



      function showEventStep() {
        const match = matches.find((m) => m.id === currentEventMatch);
        const modal = document.getElementById("eventModal");
        const title = document.getElementById("eventModalTitle");
        const content = document.getElementById("eventModalContent");

        if (currentEventType === "goal") {
          if (eventStep === 1) {
            title.textContent = "Select Team";
            content.innerHTML = `
                        <div style="display: flex; flex-direction: column; gap: 10px;" id="teamBtnContainer">
                            <button class="btn-primary" style="padding: 15px;" data-team="${
                              match.team1
                            }">${teams[match.team1].name}</button>
                            <button class="btn-primary" style="padding: 15px;" data-team="${
                              match.team2
                            }">${teams[match.team2].name}</button>
                        </div>
                    `;
            setTimeout(() => {
              document
                .querySelectorAll("#teamBtnContainer button")
                .forEach((btn) => {
                  btn.onclick = () => {
                    eventData.team = btn.getAttribute("data-team");
                    eventStep++;
                    showEventStep();
                  };
                });
            }, 10);
          } else if (eventStep === 2) {
            title.textContent = "Select Scorer";
            const players = teams[eventData.team].players;
            content.innerHTML = `
                        <div style="display: flex; flex-direction: column; gap: 10px; max-height: 300px; overflow-y: auto;" id="scorerBtnContainer">
                            ${players
                              .map(
                                (p, idx) =>
                                  `<button class="btn-primary" style="padding: 15px;" data-idx="${idx}">${p}</button>`
                              )
                              .join("")}
                        </div>
                    `;
            setTimeout(() => {
              document
                .querySelectorAll("#scorerBtnContainer button")
                .forEach((btn) => {
                  btn.onclick = () => {
                    const idx = parseInt(btn.getAttribute("data-idx"));
                    eventData.player = teams[eventData.team].players[idx];
                    eventStep++;
                    showEventStep();
                  };
                });
            }, 10);
          } else if (eventStep === 3) {
            title.textContent = "Select Assist (Optional)";
            const players = teams[eventData.team].players.filter(
              (p) => p !== eventData.player
            );
            content.innerHTML = `
                        <div style="display: flex; flex-direction: column; gap: 10px; max-height: 300px; overflow-y: auto;" id="assistBtnContainer">
                            <button class="btn-primary" style="padding: 15px;" data-none="true">No Assist</button>
                            ${players
                              .map(
                                (p, idx) =>
                                  `<button class="btn-primary" style="padding: 15px;" data-idx="${idx}">${p}</button>`
                              )
                              .join("")}
                        </div>
                    `;
            setTimeout(() => {
              document
                .querySelectorAll("#assistBtnContainer button")
                .forEach((btn) => {
                  btn.onclick = () => {
                    if (btn.getAttribute("data-none")) {
                      eventData.assist = "";
                    } else {
                      const idx = parseInt(btn.getAttribute("data-idx"));
                      const filteredPlayers = teams[
                        eventData.team
                      ].players.filter((p) => p !== eventData.player);
                      eventData.assist = filteredPlayers[idx];
                    }
                    recordGoal(currentEventMatch);
                    closeEventModal();
                  };
                });
            }, 10);
          }
        } else if (currentEventType === "owngoal") {
          if (eventStep === 1) {
            title.textContent = "Select Team (Own Goal)";
            content.innerHTML = `
                        <div style="display: flex; flex-direction: column; gap: 10px;" id="ownTeamBtnContainer">
                            <button class="btn-primary" style="padding: 15px;" data-team="${
                              match.team1
                            }">${teams[match.team1].name}</button>
                            <button class="btn-primary" style="padding: 15px;" data-team="${
                              match.team2
                            }">${teams[match.team2].name}</button>
                        </div>
                    `;
            setTimeout(() => {
              document
                .querySelectorAll("#ownTeamBtnContainer button")
                .forEach((btn) => {
                  btn.onclick = () => {
                    eventData.team = btn.getAttribute("data-team");
                    eventStep++;
                    showEventStep();
                  };
                });
            }, 10);
          } else if (eventStep === 2) {
            title.textContent = "Select Player (Own Goal)";
            const players = teams[eventData.team].players;
            content.innerHTML = `
                        <div style="display: flex; flex-direction: column; gap: 10px; max-height: 300px; overflow-y: auto;" id="ownPlayerBtnContainer">
                            ${players
                              .map(
                                (p, idx) =>
                                  `<button class="btn-primary" style="padding: 15px;" data-idx="${idx}">${p}</button>`
                              )
                              .join("")}
                        </div>
                    `;
            setTimeout(() => {
              document
                .querySelectorAll("#ownPlayerBtnContainer button")
                .forEach((btn) => {
                  btn.onclick = () => {
                    const idx = parseInt(btn.getAttribute("data-idx"));
                    eventData.player = teams[eventData.team].players[idx];
                    recordOwnGoal(currentEventMatch);
                    closeEventModal();
                  };
                });
            }, 10);
          }
        }

        modal.style.display = "flex";
      }

      function recordGoal(matchId) {
        const match = matches.find((m) => m.id === matchId);
        const elapsedTime = match.startTimeUTC
          ? Math.floor(
              (Date.now() - new Date(match.startTimeUTC).getTime()) / 1000
            )
          : 0;
        const minutes = Math.floor(elapsedTime / 60);

        match.goals.push({
          team: eventData.team,
          scorer: eventData.player,
          assist: eventData.assist || "",
          ownGoal: false,
          time: minutes,
          type: "goal",
        });

        const scorerId = `${eventData.team}-${eventData.player}`;
        playerStats[scorerId].goals++;

        if (eventData.assist) {
          const assistId = `${eventData.team}-${eventData.assist}`;
          playerStats[assistId].assists++;
        }

        if (eventData.team === match.team1) {
          match.score1++;
        } else {
          match.score2++;
        }

        const isFinal = match.round === "final";
        if (!isFinal && (match.score1 >= 3 || match.score2 >= 3)) {
          endMatch(matchId);
        } else {
          renderMatches();
          updateLeaderboard();
          updateTournamentStorage();
        }
      }

      function recordOwnGoal(matchId) {
        const match = matches.find((m) => m.id === matchId);
        const elapsedTime = match.startTimeUTC
          ? Math.floor(
              (Date.now() - new Date(match.startTimeUTC).getTime()) / 1000
            )
          : 0;
        const minutes = Math.floor(elapsedTime / 60);

        match.goals.push({
          team: eventData.team,
          scorer: eventData.player,
          assist: "",
          ownGoal: true,
          time: minutes,
          type: "goal",
        });

        const scorerId = `${eventData.team}-${eventData.player}`;
        if (!playerStats[scorerId].ownGoals) playerStats[scorerId].ownGoals = 0;
        playerStats[scorerId].ownGoals++;

        if (eventData.team === match.team1) {
          match.score2++;
        } else {
          match.score1++;
        }

        const isFinal = match.round === "final";
        if (!isFinal && (match.score1 >= 3 || match.score2 >= 3)) {
          endMatch(matchId);
        } else {
          renderMatches();
          updateLeaderboard();
          updateTournamentStorage();
        }
      }



      /**
       * Record a save quickly without showing modal
       * @param {number} matchId - The match ID
       * @param {string} teamKey - The team key (e.g., 'red', 'black', 'white')
       */
      function recordQuickSave(matchId, teamKey) {
        if (!checkAdmin()) return;

        const match = matches.find((m) => m.id === matchId);
        if (!match || match.status !== "live") {
          alert("Match must be live to record a save");
          return;
        }

        const keeper = teamKey === match.team1 ? match.keeper1 : match.keeper2;
        
        if (!keeper) {
          alert("Goalkeeper not assigned for this team");
          return;
        }

        const elapsedTime = match.startTimeUTC
          ? Math.floor(
              (Date.now() - new Date(match.startTimeUTC).getTime()) / 1000
            )
          : 0;
        const minutes = Math.floor(elapsedTime / 60);

        match.goals.push({
          team: teamKey,
          scorer: keeper,
          assist: "",
          ownGoal: false,
          time: minutes,
          type: "save",
        });

        const keeperId = `${teamKey}-${keeper}`;
        keeperStats[keeperId].saves++;

        renderMatches();
        updateLeaderboard();
        updateTournamentStorage();
      }

      function closeEventModal() {
        document.getElementById("eventModal").style.display = "none";
        currentEventMatch = null;
        currentEventType = null;
        eventStep = 0;
        eventData = {};
      }

      function updateStandings(match) {
        // Don't update standings for final matches or abandoned matches
        if (match.round === "final" || match.status === "ABANDONED") {
          return;
        }

        const s1 = standings[match.team1];
        const s2 = standings[match.team2];

        s1.played++;
        s2.played++;
        s1.gf += match.score1;
        s1.ga += match.score2;
        s2.gf += match.score2;
        s2.ga += match.score1;

        if (!s1.cleanSheets) s1.cleanSheets = 0;
        if (!s2.cleanSheets) s2.cleanSheets = 0;

        if (match.score2 === 0) s1.cleanSheets++;
        if (match.score1 === 0) s2.cleanSheets++;

        if (match.score1 > match.score2) {
          s1.won++;
          s1.points += 3;
          s2.lost++;
        } else if (match.score2 > match.score1) {
          s2.won++;
          s2.points += 3;
          s1.lost++;
        } else {
          s1.drawn++;
          s2.drawn++;
          s1.points += 1;
          s2.points += 1;
        }
      }

      function updateTable() {
        const tbody = document.getElementById("tableBody");
        if (!tbody) return;

        const sorted = getSortedStandings();

        const tableHTML = sorted
          .map(
            (team, idx) => `
                <tr>
                    <td>${idx + 1}</td>
                    <td style="color: ${
                      teams[team.key].color
                    }; font-weight: bold;">${teams[team.key].name}</td>
                    <td>${team.played}</td>
                    <td>${team.won}</td>
                    <td>${team.drawn}</td>
                    <td>${team.lost}</td>
                    <td>${team.gf}</td>
                    <td>${team.ga}</td>
                    <td>${team.gd >= 0 ? "+" : ""}${team.gd}</td>
                    <td>${team.cs}</td>
                    <td><strong>${team.points}</strong></td>
                </tr>
            `
          )
          .join("");

        if (tbody) {
          tbody.innerHTML = tableHTML;
        }
      }

      function getHeadToHead(team1, team2) {
        const h2hMatches = matches.filter(
          (m) =>
            m.status === "completed" &&
            m.round !== "final" &&
            ((m.team1 === team1 && m.team2 === team2) ||
              (m.team1 === team2 && m.team2 === team1))
        );

        let points1 = 0;
        let points2 = 0;

        h2hMatches.forEach((m) => {
          const isTeam1Home = m.team1 === team1;
          const score1 = isTeam1Home ? m.score1 : m.score2;
          const score2 = isTeam1Home ? m.score2 : m.score1;

          if (score1 > score2) points1 += 3;
          else if (score2 > score1) points2 += 3;
          else {
            points1 += 1;
            points2 += 1;
          }
        });

        return points1 - points2;
      }

      function createFinal() {
        const sorted = getSortedStandings();

        // Check if top 3 teams are completely equal
        if (sorted.length >= 3) {
          const top3 = sorted.slice(0, 3);
          const allEqual =
            top3[0].points === top3[1].points &&
            top3[1].points === top3[2].points &&
            top3[0].gd === top3[1].gd &&
            top3[1].gd === top3[2].gd &&
            top3[0].gf === top3[1].gf &&
            top3[1].gf === top3[2].gf &&
            top3[0].cs === top3[1].cs &&
            top3[1].cs === top3[2].cs;

          if (allEqual) {
            // Check if H2H forms a circle (each team beat one, lost to one)
            const h2h12 = getHeadToHead(top3[0].key, top3[1].key);
            const h2h13 = getHeadToHead(top3[0].key, top3[2].key);
            const h2h23 = getHeadToHead(top3[1].key, top3[2].key);

            // If all H2H are different (not all zeros), it's likely a circle
            if (h2h12 !== 0 || h2h13 !== 0 || h2h23 !== 0) {
              showTiebreakerSelectionThreeWay(top3);
              return;
            }
          }
        }

        // Check if top 2 teams are completely equal
        const top2 = sorted.slice(0, 2);

        if (
          top2[0].points === top2[1].points &&
          top2[0].gd === top2[1].gd &&
          getHeadToHead(top2[0].key, top2[1].key) === 0 &&
          top2[0].gf === top2[1].gf &&
          top2[0].cs === top2[1].cs
        ) {
          showTiebreakerSelection(top2);
        } else {
          proceedToFinal(top2[0].key, top2[1].key);
          showQualificationNote(sorted);
        }
      }

      function showTiebreakerSelectionThreeWay(top3) {
        tiebreakerTeams = top3;
        const matchesGrid = document.getElementById("matchesGrid");

        const tiebreakerHTML = `
                <div class="tiebreaker-modal">
                    <h3>‚ö†Ô∏è Three-Way Tie - Management Decision Required!</h3>
                    <p style="margin-bottom: 15px; color: #856404;">
                        All three teams are completely tied on Points (${
                          top3[0].points
                        }), Goal Difference (${top3[0].gd >= 0 ? "+" : ""}${
          top3[0].gd
        }), 
                        Goals Scored (${top3[0].gf}), and Clean Sheets (${
          top3[0].cs
        }). Head-to-Head forms a circle with no clear winner.
                        <br><br>
                        <strong>Please select which TWO teams should advance to the final:</strong>
                    </p>
                    <div style="display: grid; gap: 10px;">
                        <div class="team-option" onclick="selectTiebreakerTeams(0, 1)" style="border-color: #667eea;">
                            <span style="color: ${
                              teams[top3[0].key].color
                            }; font-weight: bold;">${
          teams[top3[0].key].name
        }</span> vs 
                            <span style="color: ${
                              teams[top3[1].key].color
                            }; font-weight: bold;">${
          teams[top3[1].key].name
        }</span>
                        </div>
                        <div class="team-option" onclick="selectTiebreakerTeams(0, 2)" style="border-color: #667eea;">
                            <span style="color: ${
                              teams[top3[0].key].color
                            }; font-weight: bold;">${
          teams[top3[0].key].name
        }</span> vs 
                            <span style="color: ${
                              teams[top3[2].key].color
                            }; font-weight: bold;">${
          teams[top3[2].key].name
        }</span>
                        </div>
                        <div class="team-option" onclick="selectTiebreakerTeams(1, 2)" style="border-color: #667eea;">
                            <span style="color: ${
                              teams[top3[1].key].color
                            }; font-weight: bold;">${
          teams[top3[1].key].name
        }</span> vs 
                            <span style="color: ${
                              teams[top3[2].key].color
                            }; font-weight: bold;">${
          teams[top3[2].key].name
        }</span>
                        </div>
                    </div>
                </div>
            `;

        matchesGrid.insertAdjacentHTML("beforeend", tiebreakerHTML);
      }

      function showQualificationNote(sorted) {
        const top2 = sorted.slice(0, 2);
        const team1 = top2[0];
        const team2 = top2[1];

        let explanation = `<strong style="color: ${teams[team1.key].color}">${
          teams[team1.key].name
        }</strong> and <strong style="color: ${teams[team2.key].color}">${
          teams[team2.key].name
        }</strong> qualified for the final. `;

        if (team1.points !== team2.points) {
          explanation += `<br><br><strong>Reason:</strong> ${
            teams[team1.key].name
          } (${team1.points} pts) and ${teams[team2.key].name} (${
            team2.points
          } pts) had the highest points.`;
        } else if (team1.gd !== team2.gd) {
          explanation += `<br><br><strong>Reason:</strong> Tied on points (${
            team1.points
          } pts each), but separated by Goal Difference. ${
            teams[team1.key].name
          } (${team1.gd >= 0 ? "+" : ""}${team1.gd} GD) finished ahead of ${
            teams[team2.key].name
          } (${team2.gd >= 0 ? "+" : ""}${team2.gd} GD).`;
        } else {
          const h2h = getHeadToHead(team1.key, team2.key);
          const h2hDetails = getHeadToHeadDetails(team1.key, team2.key);

          if (h2h !== 0) {
            explanation += `<br><br><strong>Reason:</strong> Tied on points (${
              team1.points
            } pts) and Goal Difference (${team1.gd >= 0 ? "+" : ""}${
              team1.gd
            }), separated by Head-to-Head record.`;
            explanation += `<br><br><strong>Head-to-Head between ${
              teams[team1.key].name
            } and ${teams[team2.key].name}:</strong>`;
            explanation += `<br>${h2hDetails.summary}`;
            explanation += `<br><strong>Result:</strong> ${
              teams[team1.key].name
            } earned ${h2hDetails.points1} H2H points vs ${
              teams[team2.key].name
            }'s ${h2hDetails.points2} H2H points.`;
          } else if (team1.gf !== team2.gf) {
            explanation += `<br><br><strong>Reason:</strong> Tied on points, GD, and H2H, separated by Goals Scored. ${
              teams[team1.key].name
            } (${team1.gf} goals) scored more than ${teams[team2.key].name} (${
              team2.gf
            } goals).`;
          } else if (team1.cs !== team2.cs) {
            explanation += `<br><br><strong>Reason:</strong> Tied on points, GD, H2H, and Goals Scored, separated by Clean Sheets. ${
              teams[team1.key].name
            } (${team1.cs} CS) had more clean sheets than ${
              teams[team2.key].name
            } (${team2.cs} CS).`;
          }
        }

        const noteDiv = document.getElementById("qualificationNote");
        const detailsDiv = document.getElementById("qualificationDetails");

        if (detailsDiv) {
          detailsDiv.innerHTML = explanation;
        }

        if (noteDiv) {
          noteDiv.style.display = "block";
        }
      }

      function getHeadToHeadDetails(team1, team2) {
        const h2hMatches = matches.filter(
          (m) =>
            m.status === "completed" &&
            m.round !== "final" &&
            ((m.team1 === team1 && m.team2 === team2) ||
              (m.team1 === team2 && m.team2 === team1))
        );

        let points1 = 0;
        let points2 = 0;
        let summary = "";

        h2hMatches.forEach((m, idx) => {
          const isTeam1Home = m.team1 === team1;
          const score1 = isTeam1Home ? m.score1 : m.score2;
          const score2 = isTeam1Home ? m.score2 : m.score1;

          summary += `Round ${m.round}: ${teams[team1].name} ${score1}-${score2} ${teams[team2].name}`;

          if (score1 > score2) {
            points1 += 3;
            summary += ` (${teams[team1].name} won)`;
          } else if (score2 > score1) {
            points2 += 3;
            summary += ` (${teams[team2].name} won)`;
          } else {
            points1 += 1;
            points2 += 1;
            summary += ` (Draw)`;
          }

          if (idx < h2hMatches.length - 1) summary += "<br>";
        });

        return { points1, points2, summary };
      }

      function showTiebreakerSelection(top2) {
        tiebreakerTeams = top2;
        const matchesGrid = document.getElementById("matchesGrid");

        const tiebreakerHTML = `
                <div class="tiebreaker-modal">
                    <h3>‚ö†Ô∏è Tiebreaker Required - All Stats Equal!</h3>
                    <p style="margin-bottom: 15px; color: #856404;">
                        Both teams are completely tied. Please select which teams should advance to the final:
                    </p>
                    <div style="display: grid; gap: 10px;">
                        <div class="team-option" onclick="selectTiebreakerTeams(0, 1)" style="color: ${
                          teams[top2[0].key].color
                        }; border-color: ${teams[top2[0].key].color};">
                            1. ${teams[top2[0].key].name} vs ${
          teams[top2[1].key].name
        }
                        </div>
                    </div>
                </div>
            `;

        matchesGrid.insertAdjacentHTML("beforeend", tiebreakerHTML);
      }

      function selectTiebreakerTeams(idx1, idx2) {
        if (!checkAdmin()) return;

        const team1 = tiebreakerTeams[idx1].key;
        const team2 = tiebreakerTeams[idx2].key;

        document.querySelector(".tiebreaker-modal").remove();
        proceedToFinal(team1, team2);
      }

      function proceedToFinal(team1, team2) {
        // team1 is always the team that finished first in the points table
        // So team1 gets the kick-off
        const kickoffTeam = team1;

        matches.push({
          id: matches.length,
          round: "final",
          team1: team1,
          team2: team2,
          score1: 0,
          score2: 0,
          status: "pending",
          timer: CONFIG.MATCH_DURATION_SECONDS,
          interval: null,
          goals: [],
          keeper1: null,
          keeper2: null,
          paused: false,
          kickoffTeam: kickoffTeam,
        });

        // Save the final match to Firebase
        updateTournamentStorage();

        renderMatches();

        if (tiebreakerTeams && tiebreakerTeams.length === 3) {
          const noteDiv = document.getElementById("qualificationNote");
          const detailsDiv = document.getElementById("qualificationDetails");
          if (detailsDiv) {
            detailsDiv.innerHTML = `<strong style="color: ${teams[team1].color}">${teams[team1].name}</strong> and <strong style="color: ${teams[team2].color}">${teams[team2].name}</strong> qualified for the final.<br><br><strong>Reason:</strong> Three-way tie with all metrics equal. Selected by management decision.`;
          }
          if (noteDiv) {
            noteDiv.style.display = "block";
          }
        }
      }

      function formatTime(seconds) {
        const mins = Math.floor(seconds / 60);
        const secs = seconds % 60;
        return `${mins}:${secs.toString().padStart(2, "0")}`;
      }

      function formatElapsedTime(seconds) {
        const mins = Math.floor(seconds / 60);
        const secs = seconds % 60;
        return `${mins}:${secs.toString().padStart(2, "0")}`;
      }

      function isTournamentComplete() {
        // 1. Classic completion: Final match exists and is completed
        const finalMatch = matches.find((m) => m.round === "final");
        if (finalMatch && finalMatch.status === "completed") return true;

        // 2. Special case: Final match deleted or not created, but all league matches completed
        const leagueMatches = matches.filter((m) => m.round !== "final");
        const allLeagueCompleted =
          leagueMatches.length > 0 &&
          leagueMatches.every((m) => m.status === "completed");

        if (!finalMatch && allLeagueCompleted) return true;

        // 3. User manually ended tournament (has ABANDONED matches)
        if (isTournamentEnded()) return true;

        return false;
      }

      function isTournamentEnded() {
        // Tournament is considered "ended" if it has any ABANDONED matches
        // This means the tournament was manually ended before completion
        return matches.some((m) => m.status === "ABANDONED");
      }

      function updateTournamentStatus() {
        const statusElement = document.getElementById("tournamentStatus");
        if (!statusElement) return;

        // Check if tournament has ended (has ABANDONED matches) or completed (final match done)
        if (isTournamentEnded() || isTournamentComplete()) {
          statusElement.innerHTML =
            '‚úÖ <span style="color: #4caf50;">Completed</span>';
          return;
        }

        // Check if any match has started
        const hasStartedMatch = matches.some(
          (m) => m.status === "completed" || m.status === "live"
        );
        if (hasStartedMatch) {
          statusElement.innerHTML =
            '‚ö° <span style="color: #ff9800;">In Progress...</span>';
          return;
        }

        // Tournament not started yet
        statusElement.innerHTML =
          '‚è≥ <span style="color: #666;">Yet to begin...</span>';
      }

      function reorganizePageForCompletedTournament() {
        if (!isTournamentComplete()) {
          pageReorganized = false; // Reset flag if tournament not complete
          return; // Not complete yet, keep normal layout
        }

        // Only reorganize once - prevent multiple reorganizations
        if (pageReorganized) {
          return;
        }

        console.log("üîÑ Reorganizing page for completed tournament...");

        const finalMatch = matches.find((m) => m.round === "final");
        let winner = null;
        if (finalMatch) {
            winner =
              finalMatch.score1 > finalMatch.score2
                ? finalMatch.team1
                : finalMatch.score2 > finalMatch.score1
                ? finalMatch.team2
                : null;
        }

        // Get the main container
        const detailPage = document.getElementById("tournamentDetailPage");

        // Get header (first child)
        const header = detailPage.querySelector("div:first-child");

        // Remove all children except header
        const allChildren = Array.from(detailPage.children);
        allChildren.forEach((child) => {
          if (child !== header) {
            child.remove();
          }
        });

        // Now add sections in the correct order

        // 1. Header (already there)

        // 2. TOURNAMENT WINNER
        let showFinalMatch = true;

        if (!winner) {
          console.log("‚ö†Ô∏è Final ended in draw. Discarding final match and using league standings.");
          showFinalMatch = false;

          // 1. Determine Winner from League Standings
          const sorted = getSortedStandings();
          
          winner = sorted[0].key;

          // 2. Discard Final Match Stats (Revert Clean Sheets & Saves)
          if (finalMatch) {
             const k1 = `${finalMatch.team1}-${finalMatch.keeper1}`;
             const k2 = `${finalMatch.team2}-${finalMatch.keeper2}`;
             
             // Revert Clean Sheets
             if (keeperStats[k1]) keeperStats[k1].cleanSheets--;
             if (keeperStats[k2]) keeperStats[k2].cleanSheets--;
             
             // Revert Saves
             if (finalMatch.goals) {
                finalMatch.goals.forEach(goal => {
                    if (goal.type === 'save' && keeperStats[goal.scorer]) {
                        keeperStats[goal.scorer].saves--;
                    }
                });
             }
             
             console.log("Reverted clean sheet and save stats for final match keepers.");
          }
        }

        if (winner) {
          const winnerSection = createTournamentWinnerBanner({
            winnerName: teams[winner].name,
            winnerColor: teams[winner].color,
          });
          detailPage.appendChild(winnerSection);
        }

        // 3. FINAL MATCH (Only show if not discarded)
        if (showFinalMatch) {
            const finalMatchSection = document.createElement("div");
            finalMatchSection.id = "finalMatchSection";
            finalMatchSection.className = "section";
            finalMatchSection.innerHTML = `
                    <h2>üèÜ Final Match</h2>
                    <div class="matches-grid">
                        ${separateFinalMatch()}
                    </div>
                `;
            detailPage.appendChild(finalMatchSection);
        }

        // 4. TOP PERFORMERS
        const topLeaderboardSection = createTopLeaderboardSection();
        detailPage.appendChild(topLeaderboardSection);

        // 5. POINTS TABLE
        const tableSection = window.pointsTableView();
        detailPage.appendChild(tableSection);
        updateTable(); // Re-populate the table

        // 6. LEADERBOARD
        const leaderboardSection = document.createElement("div");
        leaderboardSection.className = "section";
        leaderboardSection.id = "leaderboardSection";
        leaderboardSection.innerHTML = `
                <h2>Leaderboard</h2>
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 20px;">
                    <div style="background: #fff; padding: 15px; border-radius: 10px; border-left: 4px solid #ffc107;">
                        <h3 style="color: #ffc107; margin-bottom: 10px;">‚öΩ Top Scorers</h3>
                        <div id="topScorers" style="max-height: 300px; overflow-y: auto;"></div>
                    </div>
                    <div style="background: #fff; padding: 15px; border-radius: 10px; border-left: 4px solid #667eea;">
                        <h3 style="color: #667eea; margin-bottom: 10px;">üéØ Top Assists</h3>
                        <div id="topAssists" style="max-height: 300px; overflow-y: auto;"></div>
                    </div>
                    <div style="background: #fff; padding: 15px; border-radius: 10px; border-left: 4px solid #dc3545;">
                        <h3 style="color: #dc3545; margin-bottom: 10px;">üò¨ Own Goals</h3>
                        <div id="ownGoals" style="max-height: 300px; overflow-y: auto;"></div>
                    </div>
                    <div style="background: #fff; padding: 15px; border-radius: 10px; border-left: 4px solid #28a745;">
                        <h3 style="color: #28a745; margin-bottom: 10px;">üß§ Keeper Saves</h3>
                        <div id="topKeeper" style="max-height: 300px; overflow-y: auto;"></div>
                    </div>
                    <div style="background: #fff; padding: 15px; border-radius: 10px; border-left: 4px solid #17a2b8;">
                        <h3 style="color: #17a2b8; margin-bottom: 10px;">üõ°Ô∏è Clean Sheets (Teams)</h3>
                        <div id="mostCleanSheets" style="max-height: 300px; overflow-y: auto;"></div>
                    </div>
                    <div style="background: #fff; padding: 15px; border-radius: 10px; border-left: 4px solid #d32f2f;">
                        <h3 style="color: #d32f2f; margin-bottom: 10px;">üî• Goals Scored (Teams)</h3>
                        <div id="mostGoals" style="max-height: 300px; overflow-y: auto;"></div>
                    </div>
                    <div style="background: #fff; padding: 15px; border-radius: 10px; border-left: 4px solid #ff6b6b;">
                        <h3 style="color: #ff6b6b; margin-bottom: 10px;">‚ö†Ô∏è Goals Conceded (Teams)</h3>
                        <div id="mostConceded" style="max-height: 300px; overflow-y: auto;"></div>
                    </div>
                    <div style="background: #fff; padding: 15px; border-radius: 10px; border-left: 4px solid #6f42c1;">
                        <h3 style="color: #6f42c1; margin-bottom: 10px;">üìä Goal Difference (Teams)</h3>
                        <div id="bestGD" style="max-height: 300px; overflow-y: auto;"></div>
                    </div>
                </div>
            `;
        detailPage.appendChild(leaderboardSection);
        updateLeaderboard(); // Re-populate leaderboard

        // 7. LEAGUE MATCHES (without final)
        const matchesSection = document.createElement("div");
        matchesSection.className = "section";
        matchesSection.id = "matchesSection";
        matchesSection.innerHTML = `
                <h2>League Matches</h2>
                <div class="matches-grid" id="matchesGrid"></div>
            `;
        detailPage.appendChild(matchesSection);

        // Re-render matches (will exclude final due to filter in renderMatches)
        const grid = document.getElementById("matchesGrid");
        const leagueMatches = matches.filter((m) => m.round !== "final");
        // Use centralized match card generator (no controls since tournament is complete)
        grid.innerHTML = leagueMatches
          .map((match) => createMatchCardHTML(match, { showControls: false }))
          .join("");

        // 8. TOURNAMENT SUMMARY (admin only)
        if (isAdmin) {
          // Generate summary message
          const summaryMessage = generateTournamentSummaryMessage();

          // Use whatsappMessageView component directly (no extra wrapper)
          const viewElement = window.whatsappMessageView({
            icon: "üì±",
            title: "Share Tournament Summary on Social Media",
            message: summaryMessage,
            buttonTitle: "üìã Copy Summary",
          });

          detailPage.appendChild(viewElement);
        }

        // 9. TOURNAMENT LINK
        const shareLink = getTournamentShareLink(currentTournamentId);

        // Use whatsappMessageView component directly (no extra wrapper)
        const linkViewElement = window.whatsappMessageView({
          icon: "üîó",
          title: "Tournament Link",
          subtitle: "Share this link to view the tournament results:",
          message: shareLink,
          buttonTitle: "üìã Copy Link",
        });

        detailPage.appendChild(linkViewElement);

        // 10. END TOURNAMENT & DELETE TOURNAMENT (admin only)
        if (isAdmin) {
          const adminActionsSection = document.createElement("div");
          adminActionsSection.id = "adminActionsSection";
          adminActionsSection.className = "section";
          adminActionsSection.style.textAlign = "center";
          adminActionsSection.style.marginTop = "30px";

          const tournamentEndedOrComplete =
            isTournamentEnded() || isTournamentComplete();
          const endButtonHtml = tournamentEndedOrComplete
            ? ""
            : `
                    <button id="endTournamentBtn" style="min-width: 250px; padding: 12px 30px; font-size: 16px; margin: 0 8px 15px 8px; background: #ff9800; color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: 600;" onclick="endTournament()">
                        üèÅ End Tournament
                    </button>
          `;

          adminActionsSection.innerHTML = `
                    ${endButtonHtml}
                    <button id="deleteTournamentBtn" style="min-width: 250px; padding: 12px 30px; font-size: 16px; margin: 0 8px 15px 8px; background: #c62828; color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: 600;" onclick="deleteTournament('${currentTournamentId}')">
                        üóëÔ∏è Delete Tournament
                    </button>
                `;
          detailPage.appendChild(adminActionsSection);
        }

        // Footer (version and UTC)
        const footer = document.createElement("div");
        footer.style.cssText =
          "margin-top: 30px; padding: 20px; display: flex; justify-content: space-between; align-items: center; color: #999; font-size: 0.75em; border-top: 1px solid #eee;";
        footer.innerHTML = `
                <span class="app-version">${CONFIG.APP_VERSION}</span>
                <span>UTC: <span class="deviceUTC">--</span></span>
            `;
        detailPage.appendChild(footer);

        // Mark as reorganized
        pageReorganized = true;
        console.log("‚úÖ Page reorganization complete");
      }

      function createTopLeaderboardSection() {
        const topLeaderboardSection = document.createElement("div");
        topLeaderboardSection.id = "topLeaderboardSection";
        topLeaderboardSection.className = "section";

        const stats = generateLeaderboardStats();

        topLeaderboardSection.innerHTML = `
                <h2>üèÖ Top Performers</h2>
                <div style="background: #fff; padding: 25px; border-radius: 10px; box-shadow: 0 2px 10px rgba(0,0,0,0.1);">
                    <div style="margin-bottom: 30px;">
                        <h3 style="color: #667eea; border-bottom: 2px solid #667eea; padding-bottom: 10px; margin-bottom: 15px;">
                            üèÖ INDIVIDUAL AWARDS
                        </h3>
                        
                        ${
                          stats.topScorers.length > 0
                            ? `
                            <div style="margin-bottom: 20px;">
                                <h4 style="color: #ffc107; margin-bottom: 10px;">‚öΩ TOP SCORER${
                                  stats.topScorers.length > 1 ? "S" : ""
                                }</h4>
                                ${stats.topScorers
                                  .map(
                                    (p) => `
                                    <div style="padding: 8px; background: #fff8e1; border-left: 4px solid #ffc107; margin-bottom: 5px; border-radius: 4px;">
                                        ü•á <strong>${p.name}</strong> (${
                                      teams[p.team].name
                                    }) - ${p.goals} goal${
                                      p.goals > 1 ? "s" : ""
                                    }
                                    </div>
                                `
                                  )
                                  .join("")}
                            </div>
                        `
                            : ""
                        }

                        ${
                          stats.topAssisters.length > 0
                            ? `
                            <div style="margin-bottom: 20px;">
                                <h4 style="color: #667eea; margin-bottom: 10px;">üéØ TOP ASSIST${
                                  stats.topAssisters.length > 1 ? "S" : ""
                                }</h4>
                                ${stats.topAssisters
                                  .map(
                                    (p) => `
                                    <div style="padding: 8px; background: #e8eaf6; border-left: 4px solid #667eea; margin-bottom: 5px; border-radius: 4px;">
                                        ü•á <strong>${p.name}</strong> (${
                                      teams[p.team].name
                                    }) - ${p.assists} assist${
                                      p.assists > 1 ? "s" : ""
                                    }
                                    </div>
                                `
                                  )
                                  .join("")}
                            </div>
                        `
                            : ""
                        }

                        ${
                          stats.topKeepers.length > 0
                            ? `
                            <div style="margin-bottom: 20px;">
                                <h4 style="color: #28a745; margin-bottom: 10px;">üß§ BEST GOALKEEPER${
                                  stats.topKeepers.length > 1 ? "S" : ""
                                }</h4>
                                ${stats.topKeepers
                                  .map(
                                    (k) => `
                                    <div style="padding: 8px; background: #e8f5e9; border-left: 4px solid #28a745; margin-bottom: 5px; border-radius: 4px;">
                                        ü•á <strong>${k.name}</strong> (${
                                      teams[k.team].name
                                    }) - ${k.saves} save${
                                      k.saves > 1 ? "s" : ""
                                    }
                                    </div>
                                `
                                  )
                                  .join("")}
                            </div>
                        `
                            : ""
                        }

                        ${
                          stats.ownGoalScorers.length > 0
                            ? `
                            <div style="margin-bottom: 20px;">
                                <h4 style="color: #dc3545; margin-bottom: 10px;">üò¨ OWN GOAL${
                                  stats.ownGoalScorers.length > 1 ? "S" : ""
                                }</h4>
                                ${stats.ownGoalScorers
                                  .map(
                                    (p) => `
                                    <div style="padding: 8px; background: #ffebee; border-left: 4px solid #dc3545; margin-bottom: 5px; border-radius: 4px;">
                                        ‚Ä¢ <strong>${p.name}</strong> (${
                                      teams[p.team].name
                                    }) - ${p.ownGoals}
                                    </div>
                                `
                                  )
                                  .join("")}
                            </div>
                        `
                            : ""
                        }
                    </div>

                    <div>
                        <h3 style="color: #764ba2; border-bottom: 2px solid #764ba2; padding-bottom: 10px; margin-bottom: 15px;">
                            üèÜ TEAM AWARDS
                        </h3>

                        ${
                          stats.bestAttack.length > 0
                            ? `
                            <div style="margin-bottom: 20px;">
                                <h4 style="color: #d32f2f; margin-bottom: 10px;">üî• BEST ATTACK - MOST GOALS SCORED</h4>
                                ${stats.bestAttack
                                  .map(
                                    (t) => `
                                    <div style="padding: 8px; background: #ffebee; border-left: 4px solid #d32f2f; margin-bottom: 5px; border-radius: 4px;">
                                        <strong>${
                                          teams[t.key].name
                                        }</strong> - ${t.gf} goals
                                    </div>
                                `
                                  )
                                  .join("")}
                            </div>
                        `
                            : ""
                        }

                        ${
                          stats.bestDefense.length > 0
                            ? `
                            <div style="margin-bottom: 20px;">
                                <h4 style="color: #1976d2; margin-bottom: 10px;">üõ°Ô∏è BEST DEFENSE - LEAST GOALS CONCEDED</h4>
                                ${stats.bestDefense
                                  .map(
                                    (t) => `
                                    <div style="padding: 8px; background: #e3f2fd; border-left: 4px solid #1976d2; margin-bottom: 5px; border-radius: 4px;">
                                        <strong>${
                                          teams[t.key].name
                                        }</strong> - ${t.ga} goals conceded
                                    </div>
                                `
                                  )
                                  .join("")}
                            </div>
                        `
                            : ""
                        }

                        ${
                          stats.mostCleanSheets.length > 0
                            ? `
                            <div style="margin-bottom: 20px;">
                                <h4 style="color: #17a2b8; margin-bottom: 10px;">üß§ MOST CLEAN SHEETS</h4>
                                ${stats.mostCleanSheets
                                  .map(
                                    (t) => `
                                    <div style="padding: 8px; background: #e0f7fa; border-left: 4px solid #17a2b8; margin-bottom: 5px; border-radius: 4px;">
                                        <strong>${
                                          teams[t.key].name
                                        }</strong> - ${t.cs} clean sheets
                                    </div>
                                `
                                  )
                                  .join("")}
                            </div>
                        `
                            : ""
                        }
                    </div>
                </div>
            `;

        return topLeaderboardSection;
      }

      function separateFinalMatch() {
        // Find and return the final match HTML, remove it from main matches grid
        const finalMatch = matches.find((m) => m.round === "final");
        if (!finalMatch) return null;

        // Use centralized match card generator (no controls since tournament is complete)
        return createMatchCardHTML(finalMatch, {
          showControls: false,
          isFinal: true,
        });
      }

      function renderWinnerSection(winnerTeam) {
        const existingWinnerSection = document.getElementById("winnerSection");
        if (existingWinnerSection) {
          existingWinnerSection.remove();
        }

        const winnerSection = createTournamentWinnerBanner({
          winnerName: teams[winnerTeam].name,
          winnerColor: teams[winnerTeam].color,
        });

        // Move winner section to the top (after header)
        const detailPage = document.getElementById("tournamentDetailPage");
        const header = detailPage.querySelector("div:first-child");
        if (header && header.nextSibling) {
          detailPage.insertBefore(winnerSection, header.nextSibling);
        }
      }

      function renderTopLeaderboard() {
        // Create top leaderboard section if it doesn't exist
        let topLeaderboardSection = document.getElementById(
          "topLeaderboardSection"
        );
        if (!topLeaderboardSection) {
          topLeaderboardSection = document.createElement("div");
          topLeaderboardSection.id = "topLeaderboardSection";
          topLeaderboardSection.className = "section";

          // Insert after matches section
          const matchesSection = document.getElementById("matchesSection");
          if (matchesSection && matchesSection.nextSibling) {
            matchesSection.parentNode.insertBefore(
              topLeaderboardSection,
              matchesSection.nextSibling
            );
          }
        }

        // Generate leaderboard stats
        const stats = generateLeaderboardStats();

        const html = `
                <h2>üèÖ Top Performers</h2>
                <div style="background: #fff; padding: 25px; border-radius: 10px; box-shadow: 0 2px 10px rgba(0,0,0,0.1);">
                    <div style="margin-bottom: 30px;">
                        <h3 style="color: #667eea; border-bottom: 2px solid #667eea; padding-bottom: 10px; margin-bottom: 15px;">
                            üèÖ INDIVIDUAL AWARDS
                        </h3>
                        
                        ${
                          stats.topScorers.length > 0
                            ? `
                            <div style="margin-bottom: 20px;">
                                <h4 style="color: #ffc107; margin-bottom: 10px;">‚öΩ TOP SCORER${
                                  stats.topScorers.length > 1 ? "S" : ""
                                }</h4>
                                ${stats.topScorers
                                  .map(
                                    (p) => `
                                    <div style="padding: 8px; background: #fff8e1; border-left: 4px solid #ffc107; margin-bottom: 5px; border-radius: 4px;">
                                        ü•á <strong>${p.name}</strong> (${
                                      teams[p.team].name
                                    }) - ${p.goals} goal${
                                      p.goals > 1 ? "s" : ""
                                    }
                                    </div>
                                `
                                  )
                                  .join("")}
                            </div>
                        `
                            : ""
                        }

                        ${
                          stats.topAssisters.length > 0
                            ? `
                            <div style="margin-bottom: 20px;">
                                <h4 style="color: #667eea; margin-bottom: 10px;">üéØ TOP ASSIST${
                                  stats.topAssisters.length > 1 ? "S" : ""
                                }</h4>
                                ${stats.topAssisters
                                  .map(
                                    (p) => `
                                    <div style="padding: 8px; background: #e8eaf6; border-left: 4px solid #667eea; margin-bottom: 5px; border-radius: 4px;">
                                        ü•á <strong>${p.name}</strong> (${
                                      teams[p.team].name
                                    }) - ${p.assists} assist${
                                      p.assists > 1 ? "s" : ""
                                    }
                                    </div>
                                `
                                  )
                                  .join("")}
                            </div>
                        `
                            : ""
                        }

                        ${
                          stats.topKeepers.length > 0
                            ? `
                            <div style="margin-bottom: 20px;">
                                <h4 style="color: #28a745; margin-bottom: 10px;">üß§ BEST GOALKEEPER${
                                  stats.topKeepers.length > 1 ? "S" : ""
                                }</h4>
                                ${stats.topKeepers
                                  .map(
                                    (k) => `
                                    <div style="padding: 8px; background: #e8f5e9; border-left: 4px solid #28a745; margin-bottom: 5px; border-radius: 4px;">
                                        ü•á <strong>${k.name}</strong> (${
                                      teams[k.team].name
                                    }) - ${k.saves} save${
                                      k.saves > 1 ? "s" : ""
                                    }
                                    </div>
                                `
                                  )
                                  .join("")}
                            </div>
                        `
                            : ""
                        }

                        ${
                          stats.ownGoalScorers.length > 0
                            ? `
                            <div style="margin-bottom: 20px;">
                                <h4 style="color: #dc3545; margin-bottom: 10px;">üò¨ OWN GOAL${
                                  stats.ownGoalScorers.length > 1 ? "S" : ""
                                }</h4>
                                ${stats.ownGoalScorers
                                  .map(
                                    (p) => `
                                    <div style="padding: 8px; background: #ffebee; border-left: 4px solid #dc3545; margin-bottom: 5px; border-radius: 4px;">
                                        ‚Ä¢ <strong>${p.name}</strong> (${
                                      teams[p.team].name
                                    }) - ${p.ownGoals}
                                    </div>
                                `
                                  )
                                  .join("")}
                            </div>
                        `
                            : ""
                        }
                    </div>

                    <div>
                        <h3 style="color: #764ba2; border-bottom: 2px solid #764ba2; padding-bottom: 10px; margin-bottom: 15px;">
                            üèÜ TEAM AWARDS
                        </h3>

                        ${
                          stats.bestAttack.length > 0
                            ? `
                            <div style="margin-bottom: 20px;">
                                <h4 style="color: #d32f2f; margin-bottom: 10px;">üî• BEST ATTACK - MOST GOALS SCORED</h4>
                                ${stats.bestAttack
                                  .map(
                                    (t) => `
                                    <div style="padding: 8px; background: #ffebee; border-left: 4px solid #d32f2f; margin-bottom: 5px; border-radius: 4px;">
                                        <strong>${
                                          teams[t.key].name
                                        }</strong> - ${t.gf} goals
                                    </div>
                                `
                                  )
                                  .join("")}
                            </div>
                        `
                            : ""
                        }

                        ${
                          stats.bestDefense.length > 0
                            ? `
                            <div style="margin-bottom: 20px;">
                                <h4 style="color: #1976d2; margin-bottom: 10px;">üõ°Ô∏è BEST DEFENSE - LEAST GOALS CONCEDED</h4>
                                ${stats.bestDefense
                                  .map(
                                    (t) => `
                                    <div style="padding: 8px; background: #e3f2fd; border-left: 4px solid #1976d2; margin-bottom: 5px; border-radius: 4px;">
                                        <strong>${
                                          teams[t.key].name
                                        }</strong> - ${t.ga} goals conceded
                                    </div>
                                `
                                  )
                                  .join("")}
                            </div>
                        `
                            : ""
                        }

                        ${
                          stats.mostCleanSheets.length > 0
                            ? `
                            <div style="margin-bottom: 20px;">
                                <h4 style="color: #17a2b8; margin-bottom: 10px;">üß§ MOST CLEAN SHEETS</h4>
                                ${stats.mostCleanSheets
                                  .map(
                                    (t) => `
                                    <div style="padding: 8px; background: #e0f7fa; border-left: 4px solid #17a2b8; margin-bottom: 5px; border-radius: 4px;">
                                        <strong>${
                                          teams[t.key].name
                                        }</strong> - ${t.cs} clean sheets
                                    </div>
                                `
                                  )
                                  .join("")}
                            </div>
                        `
                            : ""
                        }
                    </div>
                </div>
            `;

        topLeaderboardSection.innerHTML = html;
        return topLeaderboardSection;
      }

      function generateLeaderboardStats() {
        // Get sorted standings (excluding final match stats)
        const sorted = getSortedStandings();

        // Top Scorers
        const topScorersArr = Object.values(playerStats)
          .filter((p) => p.goals > 0)
          .sort((a, b) => b.goals - a.goals);
        const topScorers =
          topScorersArr.length > 0
            ? topScorersArr.filter((p) => p.goals === topScorersArr[0].goals)
            : [];

        // Top Assisters
        const topAssistsArr = Object.values(playerStats)
          .filter((p) => p.assists > 0)
          .sort((a, b) => b.assists - a.assists);
        const topAssisters =
          topAssistsArr.length > 0
            ? topAssistsArr.filter(
                (p) => p.assists === topAssistsArr[0].assists
              )
            : [];

        // Top Keepers
        const topKeeperArr = Object.values(keeperStats)
          .filter((k) => k.saves > 0)
          .sort((a, b) => b.saves - a.saves);
        const topKeepers =
          topKeeperArr.length > 0
            ? topKeeperArr.filter((k) => k.saves === topKeeperArr[0].saves)
            : [];

        // Own Goal Scorers
        const ownGoalsArr = Object.values(playerStats)
          .filter((p) => p.ownGoals && p.ownGoals > 0)
          .sort((a, b) => b.ownGoals - a.ownGoals);
        const ownGoalScorers =
          ownGoalsArr.length > 0
            ? ownGoalsArr.filter((p) => p.ownGoals === ownGoalsArr[0].ownGoals)
            : [];

        // Best Attack (most goals)
        const maxGoals = sorted[0].gf;
        const bestAttack = sorted.filter((t) => t.gf === maxGoals);

        // Best Defense (least goals conceded)
        const minConceded = [...sorted].sort((a, b) => a.ga - b.ga)[0].ga;
        const bestDefense = sorted.filter((t) => t.ga === minConceded);

        // Most Clean Sheets
        const maxCS = [...sorted].sort((a, b) => b.cs - a.cs)[0].cs;
        const mostCleanSheets = sorted.filter((t) => t.cs === maxCS);

        return {
          topScorers,
          topAssisters,
          topKeepers,
          ownGoalScorers,
          bestAttack,
          bestDefense,
          mostCleanSheets,
        };
      }

      /**
       * Generate tournament information message
       * @returns {string} Formatted tournament message
       */
      function generateTournamentInfoMessage() {
        let currentUrl = window.location.href;

        // Handle special cases for the URL
        if (
          currentUrl.includes("about:srcdoc") ||
          currentUrl.includes("blob:") ||
          currentUrl === "about:blank"
        ) {
          currentUrl =
            "https://claude.ai - (Open this artifact and copy the URL from your browser)";
        }

        let message = `üèÜ *WEEKLY TOURNAMENT*\n\n`;

        message += `üìÖ *Date:* ${tournamentDate}\n\n`;

        message += `‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n`;

        message += `üë• *TEAMS & PLAYERS*\n\n`;

        Object.values(teams).forEach((team) => {
          message += `${team.emoji} *${team.name.toUpperCase()} TEAM* ${
            team.emoji
          }\n`;
          team.players.forEach((p, i) => {
            message += `   ${i + 1}. ${p}\n`;
          });
          message += `\n`;
        });

        message += `‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n`;
        message += `üìã *MATCH SCHEDULE*\n\n`;

        const roundRobinMatches = matches.filter((m) => m.round !== "final");
        for (let round = 1; round <= 3; round++) {
          message += `*Round ${round}*\n`;
          const roundMatches = roundRobinMatches.filter(
            (m) => m.round === round
          );
          roundMatches.forEach((m, idx) => {
            const matchNum = (round - 1) * 3 + idx + 1;

            message += `M${matchNum}: ${teams[m.team1].emoji} ${
              teams[m.team1].name
            } vs ${teams[m.team2].emoji} ${teams[m.team2].name}\n`;
          });
          message += `\n`;
        }

        message += `*FINAL*\n`;
        message += `M10: P1 vs P2\n`;
        message += `(Top 2 teams qualify)\n\n`;

        message += `‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n`;
        message += `‚öΩ *TOURNAMENT FORMAT*\n`;
        message += `‚Ä¢ 3 Rounds of Round-Robin (9 matches)\n`;
        message += `‚Ä¢ Each match: 10 minutes\n`;
        message += `‚Ä¢ First to 3 goals wins (regular matches)\n`;
        message += `‚Ä¢ Top 2 teams advance to Final\n`;
        message += `‚Ä¢ Points: Win=3, Draw=1, Loss=0\n\n`;

        message += `‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n`;
        message += `üì∫ *WATCH LIVE*\n`;
        message += `${currentUrl}\n\n`;

        message += `‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n`;
        message += `Let's go! üéâ‚öΩüî•`;

        return message;
      }

      function populateNewWhatsAppMessageView() {
        const container = document.getElementById(
          "newWhatsappMessageContainer"
        );

        // Guard clause
        if (!container || !window.whatsappMessageView) return;

        // Clear existing content
        container.innerHTML = "";

        const message = generateTournamentInfoMessage();

        const viewElement = window.whatsappMessageView({
          icon: "üì±",
          title: "Share Tournament Info on Social Media",
          message: message,
          buttonTitle: "üìã Copy Message",
        });
        container.appendChild(viewElement);
      }


      /**
       * Get sorted standings array
       * Sorts by Points -> Goal Difference -> Goals Scored -> Clean Sheets
       */
      function getSortedStandings() {
        return Object.entries(standings)
          .map(([key, val]) => ({
            key,
            ...val,
            gd: val.gf - val.ga,
            cs: val.cleanSheets || 0,
          }))
          .sort((a, b) => {
            if (b.points !== a.points) return b.points - a.points;
            if (b.gd !== a.gd) return b.gd - a.gd;
            if (b.gf !== a.gf) return b.gf - a.gf;
            return b.cs - a.cs;
          });
      }

      /**
       * Generate tournament summary message
       * @returns {string} Formatted tournament summary message
       */
      function generateTournamentSummaryMessage() {
        let message = `üèÜ *TOURNAMENT RESULTS* üèÜ\n\n`;

        message += `üìÖ *Date:* ${tournamentDate}\n\n`;

        message += `‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n`;

        // Calculate Standings first for use across the function
        const sorted = getSortedStandings();

        const final = matches.find((m) => m.round === "final");
        let winner =
          final.score1 > final.score2
            ? final.team1
            : final.score2 > final.score1
            ? final.team2
            : null;
        let runnerUp =
          final.score1 > final.score2
            ? final.team2
            : final.score2 > final.score1
            ? final.team1
            : null;

        // Fallback for drawn final
        if (!winner) {
          // Standings 
          winner = sorted[0].key;
          runnerUp = sorted[1].key;
        }

        if (winner) {
          message += `üëë *CHAMPION*\n`;
          message += `${teams[winner].name.toUpperCase()} TEAM\n\n`;

          message += `ü•à *RUNNER-UP*\n`;
          message += `${teams[runnerUp].name.toUpperCase()} TEAM\n\n`;

          message += `‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n`;
        }

        message += `üèÖ *INDIVIDUAL AWARDS*\n\n`;

        const topScorersArr = Object.values(playerStats)
          .filter((p) => p.goals > 0)
          .sort((a, b) => b.goals - a.goals);

        if (topScorersArr.length > 1) {
          const topGoals = topScorersArr[0].goals;
          const topScorers = topScorersArr.filter((p) => p.goals === topGoals);

          message += `‚öΩ *TOP SCORERS*\n`;
          topScorers.forEach((p) => {
            message += `ü•á ${p.name} (${teams[p.team].name}) - ${p.goals} goal${p.goals > 1 ? "s" : ""}\n`;
          });
        } else if (topScorersArr.length === 1) {
          const p = topScorersArr[0];
          message += `‚öΩ *TOP SCORER*\n`;
          message += `ü•á ${p.name} (${teams[p.team].name}) - ${p.goals} goal${p.goals > 1 ? "s" : ""}\n`;
        }
        message += `\n`;

        const topAssistsArr = Object.values(playerStats)
          .filter((p) => p.assists > 0)
          .sort((a, b) => b.assists - a.assists);

        if (topAssistsArr.length > 0) {
          const topAssistCount = topAssistsArr[0].assists;
          const topAssisters = topAssistsArr.filter(
            (p) => p.assists === topAssistCount
          );

          message += `üéØ *TOP ASSIST${topAssisters.length > 1 ? "S" : ""}*\n`;
          topAssisters.forEach((p) => {
            message += `ü•á ${p.name} (${teams[p.team].name}) - ${
              p.assists
            } assist${p.assists > 1 ? "s" : ""}\n`;
          });
          message += `\n`;
        }

        const topKeeperArr = Object.values(keeperStats)
          .filter((k) => k.saves > 0)
          .sort((a, b) => b.saves - a.saves);

        if (topKeeperArr.length > 0) {
          const topSaves = topKeeperArr[0].saves;
          const topKeepers = topKeeperArr.filter((k) => k.saves === topSaves);

          message += `üß§ *BEST GOALKEEPER${
            topKeepers.length > 1 ? "S" : ""
          }*\n`;
          topKeepers.forEach((k) => {
            message += `ü•á ${k.name} (${teams[k.team].name}) - ${k.saves} save${
              k.saves > 1 ? "s" : ""
            }\n`;
          });
          message += `\n`;
        }

        const ownGoalsArr = Object.values(playerStats)
          .filter((p) => p.ownGoals && p.ownGoals > 0)
          .sort((a, b) => b.ownGoals - a.ownGoals);

        if (ownGoalsArr.length > 0) {
          const topOwnGoals = ownGoalsArr[0].ownGoals;
          const topOwnGoalScorers = ownGoalsArr.filter(
            (p) => p.ownGoals === topOwnGoals
          );

          message += `üò¨ *OWN GOAL${
            topOwnGoalScorers.length > 1 ? "S" : ""
          }*\n`;
          topOwnGoalScorers.forEach((p) => {
            message += `‚Ä¢ ${p.name} (${teams[p.team].name}) - ${p.ownGoals}\n`;
          });
          message += `\n`;
        }

        message += `‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n`;

        message += `üèÜ *TEAM AWARDS*\n\n`;

        const teamMostGoals = sorted[0];
        message += `üî• *BEST ATTACK - MOST GOALS SCORED*\n`;
        message += `${teams[teamMostGoals.key].name} - ${
          teamMostGoals.gf
        } goals\n\n`;

        const teamBestDefense = [...sorted].sort((a, b) => a.ga - b.ga)[0];
        message += `üõ°Ô∏è *BEST DEFENSE - LEAST GOALS CONCEDED*\n`;
        message += `${teams[teamBestDefense.key].name} - ${
          teamBestDefense.ga
        } goals conceded\n\n`;

        const teamMostCleanSheets = [...sorted].sort((a, b) => b.cs - a.cs)[0];
        message += `üß§ *MOST CLEAN SHEETS*\n`;
        message += `${teams[teamMostCleanSheets.key].name} - ${
          teamMostCleanSheets.cs
        } clean sheets\n\n`;

        message += `‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n`;

        message += `üìä *STANDINGS*\n\n`;

        sorted.forEach((team, idx) => {
          const medal = idx === 0 ? "ü•á" : idx === 1 ? "ü•à" : "ü•â";
          message += `${medal} *${teams[team.key].name}*\n`;
          message += `   Pts: ${team.points} | P: ${team.played} | W: ${team.won} | D: ${team.drawn} | L: ${team.lost}\n`;
          message += `   GF: ${team.gf} | GA: ${team.ga} | GD: ${
            team.gd >= 0 ? "+" : ""
          }${team.gd} | CS: ${team.cs}\n\n`;
        });

        message += `‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n`;

        message += `Thanks for participating! üéâ‚öΩ\n`;
        message += `See you next time! üëã`;

        return message;
      }

      /**
       * Render tournament summary in the tournamentSummarySection
       * Uses whatsappMessageView component directly (no extra wrapper)
       */
      function renderTournamentSummary() {
        const tournamentSummarySection = document.getElementById(
          "tournamentSummarySection"
        );
        if (!tournamentSummarySection || !window.whatsappMessageView) return;

        // Clear existing content
        tournamentSummarySection.innerHTML = "";

        // Generate summary message
        const summaryMessage = generateTournamentSummaryMessage();

        // Use whatsappMessageView component directly
        const viewElement = window.whatsappMessageView({
          icon: "üì±",
          title: "Share Tournament Summary on Social Media",
          message: summaryMessage,
          buttonTitle: "üìã Copy Summary",
        });

        tournamentSummarySection.appendChild(viewElement);
      }

      function updateLeaderboard() {
        const topScorersArr = Object.values(playerStats).sort(
          (a, b) => b.goals - a.goals
        );

        document.getElementById("topScorers").innerHTML =
          topScorersArr.filter((p) => p.goals > 0).length > 0
            ? topScorersArr
                .filter((p) => p.goals > 0)
                .map(
                  (p, i) => `
                    <div style="padding: 8px; margin: 5px 0; background: #f8f9fa; border-radius: 5px; display: flex; justify-content: space-between;">
                        <span style="color: ${
                          teams[p.team].color
                        }; font-weight: bold;">${i + 1}. ${p.name}</span>
                        <span style="font-weight: bold;">${p.goals}</span>
                    </div>
                `
                )
                .join("")
            : '<div style="padding: 10px; color: #999;">No goals yet</div>';

        const topAssistsArr = Object.values(playerStats).sort(
          (a, b) => b.assists - a.assists
        );

        document.getElementById("topAssists").innerHTML =
          topAssistsArr.filter((p) => p.assists > 0).length > 0
            ? topAssistsArr
                .filter((p) => p.assists > 0)
                .map(
                  (p, i) => `
                    <div style="padding: 8px; margin: 5px 0; background: #f8f9fa; border-radius: 5px; display: flex; justify-content: space-between;">
                        <span style="color: ${
                          teams[p.team].color
                        }; font-weight: bold;">${i + 1}. ${p.name}</span>
                        <span style="font-weight: bold;">${p.assists}</span>
                    </div>
                `
                )
                .join("")
            : '<div style="padding: 10px; color: #999;">No assists yet</div>';

        const ownGoalsArr = Object.values(playerStats)
          .filter((p) => p.ownGoals > 0)
          .sort((a, b) => b.ownGoals - a.ownGoals);

        document.getElementById("ownGoals").innerHTML =
          ownGoalsArr.length > 0
            ? ownGoalsArr
                .map(
                  (p, i) => `
                    <div style="padding: 8px; margin: 5px 0; background: #f8f9fa; border-radius: 5px; display: flex; justify-content: space-between;">
                        <span style="color: ${
                          teams[p.team].color
                        }; font-weight: bold;">${i + 1}. ${p.name}</span>
                        <span style="font-weight: bold;">${p.ownGoals}</span>
                    </div>
                `
                )
                .join("")
            : '<div style="padding: 10px; color: #999;">No own goals</div>';

        const topKeeperArr = Object.values(keeperStats).sort(
          (a, b) => b.saves - a.saves
        );

        document.getElementById("topKeeper").innerHTML =
          topKeeperArr.filter((k) => k.saves > 0).length > 0
            ? topKeeperArr
                .filter((k) => k.saves > 0)
                .map(
                  (k, i) => `
                    <div style="padding: 8px; margin: 5px 0; background: #f8f9fa; border-radius: 5px; display: flex; justify-content: space-between;">
                        <span style="color: ${
                          teams[k.team].color
                        }; font-weight: bold;">${i + 1}. ${k.name}</span>
                        <span style="font-weight: bold;">${k.saves}</span>
                    </div>
                `
                )
                .join("")
            : '<div style="padding: 10px; color: #999;">No saves yet</div>';

        const teamCleanSheetsArr = Object.entries(standings)
          .map(([key, val]) => ({ key, cleanSheets: val.cleanSheets || 0 }))
          .sort((a, b) => b.cleanSheets - a.cleanSheets);

        document.getElementById("mostCleanSheets").innerHTML =
          teamCleanSheetsArr
            .map(
              (t, i) => `
                <div style="padding: 8px; margin: 5px 0; background: #f8f9fa; border-radius: 5px; display: flex; justify-content: space-between;">
                    <span style="color: ${
                      teams[t.key].color
                    }; font-weight: bold;">${i + 1}. ${teams[t.key].name}</span>
                    <span style="font-weight: bold;">${t.cleanSheets}</span>
                </div>
            `
            )
            .join("");

        const teamMostGoalsArr = Object.entries(standings)
          .map(([key, val]) => ({ key, gf: val.gf }))
          .sort((a, b) => b.gf - a.gf);

        document.getElementById("mostGoals").innerHTML = teamMostGoalsArr
          .map(
            (t, i) => `
                <div style="padding: 8px; margin: 5px 0; background: #f8f9fa; border-radius: 5px; display: flex; justify-content: space-between;">
                    <span style="color: ${
                      teams[t.key].color
                    }; font-weight: bold;">${i + 1}. ${teams[t.key].name}</span>
                    <span style="font-weight: bold;">${t.gf}</span>
                </div>
            `
          )
          .join("");

        const teamMostConcededArr = Object.entries(standings)
          .map(([key, val]) => ({ key, ga: val.ga }))
          .sort((a, b) => b.ga - a.ga);

        document.getElementById("mostConceded").innerHTML = teamMostConcededArr
          .map(
            (t, i) => `
                <div style="padding: 8px; margin: 5px 0; background: #f8f9fa; border-radius: 5px; display: flex; justify-content: space-between;">
                    <span style="color: ${
                      teams[t.key].color
                    }; font-weight: bold;">${i + 1}. ${teams[t.key].name}</span>
                    <span style="font-weight: bold;">${t.ga}</span>
                </div>
            `
          )
          .join("");

        const teamBestGDArr = Object.entries(standings)
          .map(([key, val]) => ({ key, gd: val.gf - val.ga }))
          .sort((a, b) => b.gd - a.gd);

        document.getElementById("bestGD").innerHTML = teamBestGDArr
          .map(
            (t, i) => `
                <div style="padding: 8px; margin: 5px 0; background: #f8f9fa; border-radius: 5px; display: flex; justify-content: space-between;">
                    <span style="color: ${
                      teams[t.key].color
                    }; font-weight: bold;">${i + 1}. ${teams[t.key].name}</span>
                    <span style="font-weight: bold;">${t.gd >= 0 ? "+" : ""}${
              t.gd
            }</span>
                </div>
            `
          )
          .join("");
      }

      // Initialize header view
      document.addEventListener("DOMContentLoaded", function () {
        const headerContainer = document.getElementById("header-container");
        if (headerContainer) {
          headerContainer.appendChild(headerView());
        }

        // Initialize new team setup view
        const newTeamSetupContainer = document.getElementById(
          "newTeamSetupContainer"
        );
        if (newTeamSetupContainer) {
          newTeamSetupContainer.appendChild(teamSetupView());
        }
      });
    </script>
    <script>
      document.addEventListener("DOMContentLoaded", function () {
        const versionSpans = document.querySelectorAll(".app-version");
        versionSpans.forEach((span) => {
          span.textContent = CONFIG.APP_VERSION;
        });
      });
    </script>
  </body>
</html>
